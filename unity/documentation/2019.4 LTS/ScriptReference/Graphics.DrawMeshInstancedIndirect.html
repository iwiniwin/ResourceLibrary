<!DOCTYPE html><html class="no-js" lang="zh-cn"><head><link href="https://fonts.googleapis.com/css?family=Roboto&amp;display=swap" rel="stylesheet" /><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="twitter:card" content="summary" /><meta property="og:title" content="Graphics-DrawMeshInstancedIndirect - Unity 脚本 API" /><title>Graphics-DrawMeshInstancedIndirect - Unity 脚本 API</title><meta name="description" content="使用 GPU 实例化多次绘制同一网格。" /><meta property="og:description" content="使用 GPU 实例化多次绘制同一网格。" /><meta name="author" content="Unity Technologies" /><link rel="shortcut icon" href="https://unity.com/themes/contrib/unity_base/images/favicons/favicon.ico" /><link rel="icon" type="image/png" href="../StaticFiles/images/favicons/favicon.png" /><link rel="apple-touch-icon-precomposed" sizes="152x152" href="../StaticFiles/images/favicons/apple-touch-icon-152x152.png" /><link rel="apple-touch-icon-precomposed" sizes="144x144" href="../StaticFiles/images/favicons/apple-touch-icon-144x144.png" /><link rel="apple-touch-icon-precomposed" sizes="120x120" href="../StaticFiles/images/favicons/apple-touch-icon-120x120.png" /><link rel="apple-touch-icon-precomposed" sizes="114x114" href="../StaticFiles/images/favicons/apple-touch-icon-114x114.png" /><link rel="apple-touch-icon-precomposed" sizes="72x72" href="../StaticFiles/images/favicons/apple-touch-icon-72x72.png" /><link rel="apple-touch-icon-precomposed" href="../StaticFiles/images/favicons/apple-touch-icon.png" /><meta name="msapplication-TileColor" content="#222c37" /><meta name="msapplication-TileImage" content="../StaticFiles/images/favicons/tileicon-144x144.png" /><script type="text/javascript">
        function OptanonWrapper() { }
    </script><script>
      var docs_type = 'ScriptReference';
      var lang = 'cn';
      var page = 'Graphics-DrawMeshInstancedIndirect';
      if(!page) page = 'index';
      var version = '2019.4';
      var docs_versions = [{version: '2021.1',version_string: '2021.1',supported: true},{version: '2020.3',version_string: '2020.3',supported: true},{version: '2020.2',version_string: '2020.2',supported: false},{version: '2020.1',version_string: '2020.1',supported: false},{version: '2019.4',version_string: '2019.4',supported: true},{version: '2019.3',version_string: '2019.3',supported: false},{version: '2019.2',version_string: '2019.2',supported: false},{version: '2019.1',version_string: '2019.1',supported: false},{version: '2018.4',version_string: '2018.4',supported: true},{version: '2018.3',version_string: '2018.3',supported: false},{version: '2018.2',version_string: '2018.2',supported: false},{version: '2018.1',version_string: '2018.1',supported: false},{version: '2017.4',version_string: '2017.4',supported: false},{version: '2017.3',version_string: '2017.3',supported: false},{version: '2017.2',version_string: '2017.2',supported: false},{version: '2017.1',version_string: '2017.1',supported: false},{version: '5.6',version_string: '560',supported: false},];</script><script type="text/javascript" src="../StaticFiles/js/jquery.js"></script><script type="text/javascript" src="../StaticFiles/js/core.js"></script><script type="text/javascript" src="../StaticFiles/js/jquery.sidebar.min.js"></script><script type="text/javascript" src="docdata/toc.js"></script><script type="text/javascript" src=""></script><script type="text/javascript" src="../StaticFiles/js/custom.js"></script><link rel="stylesheet" type="text/css" href="../StaticFiles/css/core.css" /><link rel="stylesheet" type="text/css" href="../StaticFiles/css/custom.css" /><link rel="canonical" href="https://docs.unity3d.com/cn/2019.4/ScriptReference/Graphics-DrawMeshInstancedIndirect.html" /><link rel="alternate" href="https://docs.unity3d.com/en/2019.4/ScriptReference/Graphics-DrawMeshInstancedIndirect.html" hreflang="en" /><link rel="alternate" href="https://docs.unity3d.com/cn/2019.4/ScriptReference/Graphics-DrawMeshInstancedIndirect.html" hreflang="zh" /><link rel="alternate" href="https://docs.unity3d.com/ja/2019.4/ScriptReference/Graphics-DrawMeshInstancedIndirect.html" hreflang="ja" /><link rel="alternate" href="https://docs.unity3d.com/es/2019.4/ScriptReference/Graphics-DrawMeshInstancedIndirect.html" hreflang="es" /><link rel="alternate" href="https://docs.unity3d.com/kr/2019.4/ScriptReference/Graphics-DrawMeshInstancedIndirect.html" hreflang="ko" /><link rel="alternate" href="https://docs.unity3d.com/ru/2019.4/ScriptReference/Graphics-DrawMeshInstancedIndirect.html" hreflang="ru" /><link rel="alternate" href="https://docs.unity3d.com/2019.4/Documentation/ScriptReference/Graphics-DrawMeshInstancedIndirect.html" hreflang="x-default" /></head><body><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5V25JL6" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><div class="header-wrapper"><div id="header" class="header"><div class="content"><div class="spacer"><div class="menu"><div id="nav-open" for="nav-input"><span></span></div><div class="logo"><a href="./index.html"></a></div><div class="search-form"><form action="30_search.html" method="get" class="apisearch"><input type="text" name="q" placeholder="搜索脚本..." autosave="Unity Reference" results="5" class="sbox field" id="q"></input><input type="submit" class="submit"></input></form></div><ul class="menu-items"><li class="menu-item"><a href="../Manual/index.html" class="">手册</a></li><li class="menu-item"><a href="../ScriptReference/index.html" class="selected">脚本 API</a></li></ul></div></div><div class="more"><div class="filler"></div><ul><li><a href="https://unity3d.com/">
                unity3d.com
              </a></li></ul></div></div></div><div class="toolbar"><div class="content"><div class="version-switcher"><div class="current toggle" data-target=".version-list"><div class="version-number"><div class="d-inline-block">
          Version:
          <b>2019.4</b></div><div class="d-inline-block arrow"></div></div></div><div class="version-list" style="display:none;"><ul class="versions"><li class="supported"><a class="docs_version_url_2021.1" href="/cn/2021.1/ScriptReference/Graphics-DrawMeshInstancedIndirect.html">2021.1</a></li><li class="supported"><a class="docs_version_url_2020.3" href="/cn/2020.3/ScriptReference/Graphics-DrawMeshInstancedIndirect.html">2020.3</a></li><li class=""><a class="docs_version_url_2020.2" href="/cn/2020.2/ScriptReference/Graphics-DrawMeshInstancedIndirect.html">2020.2</a></li><li class=""><a class="docs_version_url_2020.1" href="/cn/2020.1/ScriptReference/Graphics-DrawMeshInstancedIndirect.html">2020.1</a></li><li class="supported"><a class="docs_version_url_2019.4" href="/cn/2019.4/ScriptReference/Graphics-DrawMeshInstancedIndirect.html">2019.4</a></li><li class=""><a class="docs_version_url_2019.3" href="/cn/2019.3/ScriptReference/Graphics-DrawMeshInstancedIndirect.html">2019.3</a></li><li class=""><a class="docs_version_url_2019.2" href="/cn/2019.2/ScriptReference/Graphics-DrawMeshInstancedIndirect.html">2019.2</a></li><li class=""><a class="docs_version_url_2019.1" href="/cn/2019.1/ScriptReference/Graphics-DrawMeshInstancedIndirect.html">2019.1</a></li><li class="supported"><a class="docs_version_url_2018.4" href="/cn/2018.4/ScriptReference/Graphics-DrawMeshInstancedIndirect.html">2018.4</a></li><li class=""><a class="docs_version_url_2018.3" href="/cn/2018.3/ScriptReference/Graphics-DrawMeshInstancedIndirect.html">2018.3</a></li><li class=""><a class="docs_version_url_2018.2" href="/cn/2018.2/ScriptReference/Graphics-DrawMeshInstancedIndirect.html">2018.2</a></li><li class=""><a class="docs_version_url_2018.1" href="/cn/2018.1/ScriptReference/Graphics-DrawMeshInstancedIndirect.html">2018.1</a></li><li class=""><a class="docs_version_url_2017.4" href="/cn/2017.4/ScriptReference/Graphics-DrawMeshInstancedIndirect.html">2017.4</a></li><li class=""><a class="docs_version_url_2017.3" href="/cn/2017.3/ScriptReference/Graphics-DrawMeshInstancedIndirect.html">2017.3</a></li><li class=""><a class="docs_version_url_2017.2" href="/cn/2017.2/ScriptReference/Graphics-DrawMeshInstancedIndirect.html">2017.2</a></li><li class=""><a class="docs_version_url_2017.1" href="/cn/2017.1/ScriptReference/Graphics-DrawMeshInstancedIndirect.html">2017.1</a></li><li class=""><a class="docs_version_url_560" href="/cn/560/ScriptReference/Graphics-DrawMeshInstancedIndirect.html">5.6</a></li><div class="versionsWithThisPage" style="display:none;"><li><p>包含此页的版本：</p></li></div><div class="versionsWithoutThisPage" style="display:none;"><li><p>不含此页的版本：</p></li></div></ul><ul class="description"><li><div class="supported-box"></div>受支持</li><li><div class="legacy-box"></div>旧版</li></ul></div></div><ul class="nav-menu-items"><li class="menu-item"><a href="../Manual/index.html" class="">手册</a></li><li class="menu-item"><a href="../ScriptReference/index.html" class="selected">脚本 API</a></li></ul><div class="lang-switcher"><div class="current toggle" data-target=".lang-list"><div class="lbl">语言:
        <span class="b">中文</span></div><div class="arrow"></div></div><div class="lang-list" style="display:none;"><ul><li><a data-lang="en" href="/2019.4/Documentation/ScriptReference/Graphics-DrawMeshInstancedIndirect.html">English</a></li><li><a data-lang="cn" href="/cn/2019.4/ScriptReference/Graphics-DrawMeshInstancedIndirect.html">中文</a></li><li><a data-lang="ja" href="/ja/2019.4/ScriptReference/Graphics-DrawMeshInstancedIndirect.html">日本語</a></li><li><a data-lang="es" href="/es/2019.4/ScriptReference/Graphics-DrawMeshInstancedIndirect.html">Español</a></li><li><a data-lang="kr" href="/kr/2019.4/ScriptReference/Graphics-DrawMeshInstancedIndirect.html">한국어</a></li><li><a data-lang="ru" href="/ru/2019.4/ScriptReference/Graphics-DrawMeshInstancedIndirect.html">Русский</a></li></ul></div></div></div></div></div><div id="master-wrapper" class="master-wrapper clear"><div id="sidebar" class="sidebar hidden"><div class="sidebar-wrap"><div class="content"><div class="sidebar-menu"><div class="toc"><h2>脚本 API</h2><div class="version-switcher"><div class="current toggle" data-target=".version-list"><div class="version-number"><div class="d-inline-block">
          Version:
          <b>2019.4</b></div><div class="d-inline-block arrow"></div></div></div><div class="version-list" style="display:none;"><ul class="versions"><li class="supported"><a class="docs_version_url_2021.1" href="/cn/2021.1/ScriptReference/Graphics-DrawMeshInstancedIndirect.html">2021.1</a></li><li class="supported"><a class="docs_version_url_2020.3" href="/cn/2020.3/ScriptReference/Graphics-DrawMeshInstancedIndirect.html">2020.3</a></li><li class=""><a class="docs_version_url_2020.2" href="/cn/2020.2/ScriptReference/Graphics-DrawMeshInstancedIndirect.html">2020.2</a></li><li class=""><a class="docs_version_url_2020.1" href="/cn/2020.1/ScriptReference/Graphics-DrawMeshInstancedIndirect.html">2020.1</a></li><li class="supported"><a class="docs_version_url_2019.4" href="/cn/2019.4/ScriptReference/Graphics-DrawMeshInstancedIndirect.html">2019.4</a></li><li class=""><a class="docs_version_url_2019.3" href="/cn/2019.3/ScriptReference/Graphics-DrawMeshInstancedIndirect.html">2019.3</a></li><li class=""><a class="docs_version_url_2019.2" href="/cn/2019.2/ScriptReference/Graphics-DrawMeshInstancedIndirect.html">2019.2</a></li><li class=""><a class="docs_version_url_2019.1" href="/cn/2019.1/ScriptReference/Graphics-DrawMeshInstancedIndirect.html">2019.1</a></li><li class="supported"><a class="docs_version_url_2018.4" href="/cn/2018.4/ScriptReference/Graphics-DrawMeshInstancedIndirect.html">2018.4</a></li><li class=""><a class="docs_version_url_2018.3" href="/cn/2018.3/ScriptReference/Graphics-DrawMeshInstancedIndirect.html">2018.3</a></li><li class=""><a class="docs_version_url_2018.2" href="/cn/2018.2/ScriptReference/Graphics-DrawMeshInstancedIndirect.html">2018.2</a></li><li class=""><a class="docs_version_url_2018.1" href="/cn/2018.1/ScriptReference/Graphics-DrawMeshInstancedIndirect.html">2018.1</a></li><li class=""><a class="docs_version_url_2017.4" href="/cn/2017.4/ScriptReference/Graphics-DrawMeshInstancedIndirect.html">2017.4</a></li><li class=""><a class="docs_version_url_2017.3" href="/cn/2017.3/ScriptReference/Graphics-DrawMeshInstancedIndirect.html">2017.3</a></li><li class=""><a class="docs_version_url_2017.2" href="/cn/2017.2/ScriptReference/Graphics-DrawMeshInstancedIndirect.html">2017.2</a></li><li class=""><a class="docs_version_url_2017.1" href="/cn/2017.1/ScriptReference/Graphics-DrawMeshInstancedIndirect.html">2017.1</a></li><li class=""><a class="docs_version_url_560" href="/cn/560/ScriptReference/Graphics-DrawMeshInstancedIndirect.html">5.6</a></li><div class="versionsWithThisPage" style="display:none;"><li><p>包含此页的版本：</p></li></div><div class="versionsWithoutThisPage" style="display:none;"><li><p>不含此页的版本：</p></li></div></ul><ul class="description"><li><div class="supported-box"></div>受支持</li><li><div class="legacy-box"></div>旧版</li></ul></div></div><div class="clear"></div></div></div></div></div></div><div id="content-wrap" class="content-wrap opened-sidebar"><div class="content-block"><div class="content"><div class="section"><div class="mb20 clear" id=""><h1 class="heading inherit"><a href="Graphics.html">Graphics</a>.DrawMeshInstancedIndirect</h1><div class="clear"></div><div class="clear"></div><a href="" class="switch-link gray-btn sbtn left hide">切换到手册</a><div class="clear"></div></div><div class="subsection"><div class="signature"><div class="signature-CS sig-block"><span style="color:red;"></span>public static void <span class="sig-kw">DrawMeshInstancedIndirect</span>
        (<a href="Mesh.html">Mesh</a> <span class="sig-kw">mesh</span>,
    int <span class="sig-kw">submeshIndex</span>,
    <a href="Material.html">Material</a> <span class="sig-kw">material</span>,
    <a href="Bounds.html">Bounds</a> <span class="sig-kw">bounds</span>,
    <a href="ComputeBuffer.html">ComputeBuffer</a> <span class="sig-kw">bufferWithArgs</span>,
    int <span class="sig-kw">argsOffset</span>=
      0,
    <a href="MaterialPropertyBlock.html">MaterialPropertyBlock</a> <span class="sig-kw">properties</span>=
      null,
    <a href="Rendering.ShadowCastingMode.html">Rendering.ShadowCastingMode</a> <span class="sig-kw">castShadows</span>=
      ShadowCastingMode.On,
    bool <span class="sig-kw">receiveShadows</span>=
      true,
    int <span class="sig-kw">layer</span>=
      0,
    <a href="Camera.html">Camera</a> <span class="sig-kw">camera</span>=
      null,
    <a href="Rendering.LightProbeUsage.html">Rendering.LightProbeUsage</a> <span class="sig-kw">lightProbeUsage</span>=
      LightProbeUsage.BlendProbes,
    <a href="LightProbeProxyVolume.html">LightProbeProxyVolume</a> <span class="sig-kw">lightProbeProxyVolume</span>=
      null);
      </div></div></div><div class="subsection"><h2>参数</h2><table class="list"><tr><td class="name lbl">mesh</td><td class="desc">要绘制的 <a href="Mesh.html">Mesh</a>。</td></tr><tr><td class="name lbl">submeshIndex</td><td class="desc">要绘制网格的哪个子集。这只适用于由若干种材质构成的网格。</td></tr><tr><td class="name lbl">material</td><td class="desc">要使用的 <a href="Material.html">Material</a>。</td></tr><tr><td class="name lbl">bounds</td><td class="desc">围绕要绘制的实例的包围体。</td></tr><tr><td class="name lbl">bufferWithArgs</td><td class="desc">GPU 缓冲区包含相应的参数，指示要绘制此网格的实例数。</td></tr><tr><td class="name lbl">argsOffset</td><td class="desc">缓冲区中的字节偏移，绘制参数起始位置。</td></tr><tr><td class="name lbl">properties</td><td class="desc">要应用的其他材质属性。请参阅 <a href="MaterialPropertyBlock.html">MaterialPropertyBlock</a>。</td></tr><tr><td class="name lbl">castShadows</td><td class="desc">确定网格是否可以投射阴影。</td></tr><tr><td class="name lbl">receiveShadows</td><td class="desc">确定网格是否可以接受阴影。</td></tr><tr><td class="name lbl">layer</td><td class="desc">要使用的 <a href="../Manual/Layers.html">Layer</a>。</td></tr><tr><td class="name lbl">camera</td><td class="desc">如果为 /null/（默认值），将在所有摄像机中绘制网格。否则，仅在给定摄像机中绘制网格。</td></tr><tr><td class="name lbl">lightProbeUsage</td><td class="desc">实例的 <a href="Rendering.LightProbeUsage.html">LightProbeUsage</a>。</td></tr></table></div><div class="subsection"><h2>描述</h2><p>使用 GPU 实例化多次绘制同一网格。</p></div><div class="subsection"><p>类似于 <a href="Graphics.DrawMeshInstanced.html">Graphics.DrawMeshInstanced</a>，此函数用于绘制同一网格的多个实例，但与之不同的是，此函数中代表要绘制实例数的参数来自 /bufferWithArgs/。<br /><br />如果您需要使用实例化的着色器多次绘制同一网格，则可以使用该函数。这些网格不会被视锥体或烘焙遮挡物做进一步的剔除处理，也不进行排序以提高透明度或 Z 效率。<br /><br />带参数的缓冲区 <code class="varname">bufferWithArgs</code> 必须在给定的 <code class="varname">argsOffset</code> 偏移处具有五个整数：
每个实例的索引数、实例数、起始索引位置、基顶点位置、起始实例位置。<br /><br />仅当网格中的子网格具有不同拓扑（例如，三角形和线条）时，Unity 才需要 submeshIndex 参数。否则，有关要绘制哪个子网格的所有信息都将来自 bufferWithArgs 参数。<br /><br />下面是一个可用于绘制同一网格的多个实例的脚本：</p></div><div class="subsection">
        <pre class="codeExampleCS">using UnityEngine;
using System.Collections;<br /><br />public class ExampleClass : <a href="MonoBehaviour.html">MonoBehaviour</a> {
    public int instanceCount = 100000;
    public <a href="Mesh.html">Mesh</a> instanceMesh;
    public <a href="Material.html">Material</a> instanceMaterial;
    public int subMeshIndex = 0;<br /><br />    private int cachedInstanceCount = -1;
    private int cachedSubMeshIndex = -1;
    private <a href="ComputeBuffer.html">ComputeBuffer</a> positionBuffer;
    private <a href="ComputeBuffer.html">ComputeBuffer</a> argsBuffer;
    private uint[] args = new uint[5] { 0, 0, 0, 0, 0 };<br /><br />    void Start() {
        argsBuffer = new <a href="ComputeBuffer.html">ComputeBuffer</a>(1, args.Length * sizeof(uint), <a href="ComputeBufferType.IndirectArguments.html">ComputeBufferType.IndirectArguments</a>);
        UpdateBuffers();
    }<br /><br />    void <a href="PlayerLoop.Update.html">Update</a>() {
        // <a href="PlayerLoop.Update.html">Update</a> starting position buffer
        if (cachedInstanceCount != instanceCount || cachedSubMeshIndex != subMeshIndex)
            UpdateBuffers();<br /><br />        // Pad input
        if (<a href="Input.GetAxisRaw.html">Input.GetAxisRaw</a>("Horizontal") != 0.0f)
            instanceCount = (int)<a href="Mathf.Clamp.html">Mathf.Clamp</a>(instanceCount + <a href="Input.GetAxis.html">Input.GetAxis</a>("Horizontal") * 40000, 1.0f, 5000000.0f);<br /><br />        // Render
        <a href="Graphics.DrawMeshInstancedIndirect.html">Graphics.DrawMeshInstancedIndirect</a>(instanceMesh, subMeshIndex, instanceMaterial, new <a href="Bounds.html">Bounds</a>(<a href="Vector3-zero.html">Vector3.zero</a>, new <a href="Vector3.html">Vector3</a>(100.0f, 100.0f, 100.0f)), argsBuffer);
    }<br /><br />    void OnGUI() {
        <a href="GUI.Label.html">GUI.Label</a>(new <a href="Rect.html">Rect</a>(265, 25, 200, 30), "Instance Count: " + instanceCount.ToString());
        instanceCount = (int)<a href="GUI.HorizontalSlider.html">GUI.HorizontalSlider</a>(new <a href="Rect.html">Rect</a>(25, 20, 200, 30), (float)instanceCount, 1.0f, 5000000.0f);
    }<br /><br />    void UpdateBuffers() {
        // Ensure submesh index is in range
        if (instanceMesh != null)
            subMeshIndex = <a href="Mathf.Clamp.html">Mathf.Clamp</a>(subMeshIndex, 0, instanceMesh.subMeshCount - 1);<br /><br />        // Positions
        if (positionBuffer != null)
            positionBuffer.Release();
        positionBuffer = new <a href="ComputeBuffer.html">ComputeBuffer</a>(instanceCount, 16);
        <a href="Vector4.html">Vector4</a>[] positions = new <a href="Vector4.html">Vector4</a>[instanceCount];
        for (int i = 0; i &lt; instanceCount; i++) {
            float angle = <a href="Random.Range.html">Random.Range</a>(0.0f, <a href="Mathf.PI.html">Mathf.PI</a> * 2.0f);
            float distance = <a href="Random.Range.html">Random.Range</a>(20.0f, 100.0f);
            float height = <a href="Random.Range.html">Random.Range</a>(-2.0f, 2.0f);
            float size = <a href="Random.Range.html">Random.Range</a>(0.05f, 0.25f);
            positions[i] = new <a href="Vector4.html">Vector4</a>(<a href="Mathf.Sin.html">Mathf.Sin</a>(angle) * distance, height, <a href="Mathf.Cos.html">Mathf.Cos</a>(angle) * distance, size);
        }
        positionBuffer.SetData(positions);
        instanceMaterial.SetBuffer("positionBuffer", positionBuffer);<br /><br />        // Indirect args
        if (instanceMesh != null) {
            args[0] = (uint)instanceMesh.GetIndexCount(subMeshIndex);
            args[1] = (uint)instanceCount;
            args[2] = (uint)instanceMesh.GetIndexStart(subMeshIndex);
            args[3] = (uint)instanceMesh.GetBaseVertex(subMeshIndex);
        }
        else
        {
            args[0] = args[1] = args[2] = args[3] = 0;
        }
        argsBuffer.SetData(args);<br /><br />        cachedInstanceCount = instanceCount;
        cachedSubMeshIndex = subMeshIndex;
    }<br /><br />    void OnDisable() {
        if (positionBuffer != null)
            positionBuffer.Release();
        positionBuffer = null;<br /><br />        if (argsBuffer != null)
            argsBuffer.Release();
        argsBuffer = null;
    }
}
</pre>
      </div><div class="subsection"><p>下面是一个表面着色器，可以与上面的示例脚本配合使用：</p></div><div class="subsection">
        <pre class="codeExampleCS">
          <a href="Shader.html">Shader</a> "Instanced/InstancedSurfaceShader" {
    Properties {
        _MainTex ("Albedo (RGB)", 2D) = "white" {}
        _Glossiness ("Smoothness", <a href="SocialPlatforms.Range.html">Range</a>(0,1)) = 0.5
        _Metallic ("Metallic", <a href="SocialPlatforms.Range.html">Range</a>(0,1)) = 0.0
    }
    SubShader {
        Tags { "RenderType"="Opaque" }
        <a href="LOD.html">LOD</a> 200<br /><br />        CGPROGRAM
        // Physically based Standard lighting model
        #pragma surface surf Standard addshadow fullforwardshadows
        #pragma multi_compile_instancing
        #pragma instancing_options procedural:setup<br /><br />        sampler2D _MainTex;<br /><br />        struct <a href="Input.html">Input</a> {
            float2 uv_MainTex;
        };<br /><br />    #ifdef UNITY_PROCEDURAL_INSTANCING_ENABLED
        StructuredBuffer&lt;float4&gt; positionBuffer;
    #endif<br /><br />        void rotate2D(inout float2 v, float r)
        {
            float s, c;
            sincos(r, s, c);
            v = float2(v.x * c - v.y * s, v.x * s + v.y * c);
        }<br /><br />        void setup()
        {
        #ifdef UNITY_PROCEDURAL_INSTANCING_ENABLED
            float4 data = positionBuffer[unity_InstanceID];<br /><br />            float rotation = data.w * data.w * _Time.y * 0.5f;
            rotate2D(data.xz, rotation);<br /><br />            unity_ObjectToWorld._11_21_31_41 = float4(data.w, 0, 0, 0);
            unity_ObjectToWorld._12_22_32_42 = float4(0, data.w, 0, 0);
            unity_ObjectToWorld._13_23_33_43 = float4(0, 0, data.w, 0);
            unity_ObjectToWorld._14_24_34_44 = float4(data.xyz, 1);
            unity_WorldToObject = unity_ObjectToWorld;
            unity_WorldToObject._14_24_34 *= -1;
            unity_WorldToObject._11_22_33 = 1.0f / unity_WorldToObject._11_22_33;
        #endif
        }<br /><br />        half _Glossiness;
        half _Metallic;<br /><br />        void surf (<a href="Input.html">Input</a> IN, inout SurfaceOutputStandard o) {
            fixed4 c = tex2D (_MainTex, IN.uv_MainTex);
            o.Albedo = c.rgb;
            o.Metallic = _Metallic;
            o.Smoothness = _Glossiness;
            o.Alpha = c.a;
        }
        ENDCG
    }
    FallBack "Diffuse"
}
</pre>
      </div><div class="subsection"><p>下面是一个自定义着色器，可以与上面的示例脚本配合使用：</p></div><div class="subsection">
        <pre class="codeExampleCS">
          <a href="Shader.html">Shader</a> "Instanced/InstancedShader" {
    Properties {
        _MainTex ("Albedo (RGB)", 2D) = "white" {}
    }
    SubShader {<br /><br />        <a href="ShaderData.Pass.html">Pass</a> {<br /><br />            Tags {"<a href="Experimental.GlobalIllumination.LightMode.html">LightMode</a>"="ForwardBase"}<br /><br />            CGPROGRAM<br /><br />            #pragma vertex vert
            #pragma fragment frag
            #pragma multi_compile_fwdbase nolightmap nodirlightmap nodynlightmap novertexlight
            #pragma target 4.5<br /><br />            #include "UnityCG.cginc"
            #include "UnityLightingCommon.cginc"
            #include "AutoLight.cginc"<br /><br />            sampler2D _MainTex;<br /><br />        #if SHADER_TARGET &gt;= 45
            StructuredBuffer&lt;float4&gt; positionBuffer;
        #endif<br /><br />            struct v2f
            {
                float4 pos : SV_POSITION;
                float2 uv_MainTex : TEXCOORD0;
                float3 ambient : TEXCOORD1;
                float3 diffuse : TEXCOORD2;
                float3 color : TEXCOORD3;
                SHADOW_COORDS(4)
            };<br /><br />            void rotate2D(inout float2 v, float r)
            {
                float s, c;
                sincos(r, s, c);
                v = float2(v.x * c - v.y * s, v.x * s + v.y * c);
            }<br /><br />            v2f vert (appdata_full v, uint instanceID : SV_InstanceID)
            {
            #if SHADER_TARGET &gt;= 45
                float4 data = positionBuffer[instanceID];
            #else
                float4 data = 0;
            #endif<br /><br />                float rotation = data.w * data.w * _Time.x * 0.5f;
                rotate2D(data.xz, rotation);<br /><br />                float3 localPosition = v.vertex.xyz * data.w;
                float3 worldPosition = data.xyz + localPosition;
                float3 worldNormal = v.normal;<br /><br /><br /><br />                float3 ndotl = saturate(dot(worldNormal, _WorldSpaceLightPos0.xyz));
                float3 ambient = ShadeSH9(float4(worldNormal, 1.0f));
                float3 diffuse = (ndotl * _LightColor0.rgb);
                float3 color = v.color;<br /><br />                v2f o;
                o.pos = mul(UNITY_MATRIX_VP, float4(worldPosition, 1.0f));
                o.uv_MainTex = v.texcoord;
                o.ambient = ambient;
                o.diffuse = diffuse;
                o.color = color;
                TRANSFER_SHADOW(o)
                return o;
            }<br /><br />            fixed4 frag (v2f i) : SV_Target
            {
                fixed shadow = SHADOW_ATTENUATION(i);
                fixed4 albedo = tex2D(_MainTex, i.uv_MainTex);
                float3 lighting = i.diffuse * shadow + i.ambient;
                fixed4 output = fixed4(albedo.rgb * i.color * lighting, albedo.w);
                UNITY_APPLY_FOG(i.fogCoord, output);
                return output;
            }<br /><br />            ENDCG
        }
    }
}
</pre>
      </div></div><div class="footer-wrapper"><div class="footer clear"><div class="copy">版权所有 © 2020 Unity Technologies. Publication 2019.4</div><div class="menu"><a href="https://learn.unity.com/">教程</a><a href="https://answers.unity3d.com">社区答案</a><a href="https://support.unity3d.com/hc/en-us">知识库</a><a href="https://forum.unity3d.com">论坛</a><a href="https://unity3d.com/asset-store">Asset Store</a></div></div><div></div></div></div></div></div></div></body></html>