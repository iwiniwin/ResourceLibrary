<!DOCTYPE html><html class="no-js" lang="zh-cn">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
      new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
      })(window,document,'script','dataLayer','GTM-5V25JL6');
    </script>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="twitter:card" content="summary">
<meta property="og:title" content="托管代码剥离 - Unity 手册">
<title>托管代码剥离 - Unity 手册</title>
<meta property="og:image" content="https://docs.unity3d.com/cn/2019.4/uploads/Main/mgc_StripLevel.png">
<meta name="description" content="托管代码剥离将从构建中删除未使用的代码，从而可以显著减小最终构建大小。使用 IL2CPP 脚本后端时，托管代码剥离还可以减少构建时间，因为需要转换为 C++ 并进行编译的代码减少。托管代码剥离将从托管程序集（包括从项目中的 C# 脚本构建的程序集、包含在包和插件中的程序集以及 .NET 框架中的程序集）中删除代码。">
<meta property="og:description" content="托管代码剥离将从构建中删除未使用的代码，从而可以显著减小最终构建大小。使用 IL2CPP 脚本后端时，托管代码剥离还可以减少构建时间，因为需要转换为 C++ 并进行编译的代码减少。托管代码剥离将从托管程序集（包括从项目中的 C# 脚本构建的程序集、包含在包和插件中的程序集以及 .NET 框架中的程序集）中删除代码。">
<meta name="author" content="Unity Technologies">
<link rel="shortcut icon" href="https://unity.com/themes/contrib/unity_base/images/favicons/favicon.ico">
<link rel="icon" type="image/png" href="../StaticFiles/images/favicons/favicon.png">
<link rel="apple-touch-icon-precomposed" sizes="152x152" href="../StaticFiles/images/favicons/apple-touch-icon-152x152.png">
<link rel="apple-touch-icon-precomposed" sizes="144x144" href="../StaticFiles/images/favicons/apple-touch-icon-144x144.png">
<link rel="apple-touch-icon-precomposed" sizes="120x120" href="../StaticFiles/images/favicons/apple-touch-icon-120x120.png">
<link rel="apple-touch-icon-precomposed" sizes="114x114" href="../StaticFiles/images/favicons/apple-touch-icon-114x114.png">
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="../StaticFiles/images/favicons/apple-touch-icon-72x72.png">
<link rel="apple-touch-icon-precomposed" href="../StaticFiles/images/favicons/apple-touch-icon.png">
<meta name="msapplication-TileColor" content="#222c37">
<meta name="msapplication-TileImage" content="../StaticFiles/images/favicons/tileicon-144x144.png">
<script type="text/javascript" src="https://cdn.cookielaw.org/scripttemplates/otSDKStub.js" charset="UTF-8" data-domain-script="6e91be4c-3145-4ea2-aa64-89d716064836"></script><script type="text/javascript">
        function OptanonWrapper() { }
    </script><script>
      var docs_type = 'Manual';
      var lang = 'cn';
      var page = 'ManagedCodeStripping';
      if(!page) page = 'index';
      var version = '2019.4';
      var docs_versions = [{version: '2021.1',version_string: '2021.1',supported: true},{version: '2020.3',version_string: '2020.3',supported: true},{version: '2020.2',version_string: '2020.2',supported: false},{version: '2020.1',version_string: '2020.1',supported: false},{version: '2019.4',version_string: '2019.4',supported: true},{version: '2019.3',version_string: '2019.3',supported: false},{version: '2019.2',version_string: '2019.2',supported: false},{version: '2019.1',version_string: '2019.1',supported: false},{version: '2018.4',version_string: '2018.4',supported: true},{version: '2018.3',version_string: '2018.3',supported: false},{version: '2018.2',version_string: '2018.2',supported: false},{version: '2018.1',version_string: '2018.1',supported: false},{version: '2017.4',version_string: '2017.4',supported: false},{version: '2017.3',version_string: '2017.3',supported: false},{version: '2017.2',version_string: '2017.2',supported: false},{version: '2017.1',version_string: '2017.1',supported: false},{version: '5.6',version_string: '560',supported: false},];</script><script type="text/javascript" src="../StaticFiles/js/jquery.js"></script><script type="text/javascript" src="../StaticFiles/js/core.js"></script><script type="text/javascript" src="../StaticFiles/js/jquery.sidebar.min.js"></script><script type="text/javascript" src="docdata/toc.js"></script><script type="text/javascript" src=""></script><script type="text/javascript" src="../StaticFiles/js/custom.js"></script><link rel="stylesheet" type="text/css" href="../StaticFiles/css/core.css">
<link rel="stylesheet" type="text/css" href="../StaticFiles/css/custom.css">
<link rel="canonical" href="https://docs.unity3d.com/cn/2019.4/Manual/ManagedCodeStripping.html">
<link rel="alternate" href="https://docs.unity3d.com/en/2019.4/Manual/ManagedCodeStripping.html" hreflang="en">
<link rel="alternate" href="https://docs.unity3d.com/cn/2019.4/Manual/ManagedCodeStripping.html" hreflang="zh">
<link rel="alternate" href="https://docs.unity3d.com/ja/2019.4/Manual/ManagedCodeStripping.html" hreflang="ja">
<link rel="alternate" href="https://docs.unity3d.com/es/2019.4/Manual/ManagedCodeStripping.html" hreflang="es">
<link rel="alternate" href="https://docs.unity3d.com/kr/2019.4/Manual/ManagedCodeStripping.html" hreflang="ko">
<link rel="alternate" href="https://docs.unity3d.com/ru/2019.4/Manual/ManagedCodeStripping.html" hreflang="ru">
<link rel="alternate" href="https://docs.unity3d.com/2019.4/Documentation/Manual/ManagedCodeStripping.html" hreflang="x-default">
</head>
<body>
<noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5V25JL6" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<div class="header-wrapper">
<div id="header" class="header"><div class="content">
<div class="spacer"><div class="menu">
<div id="nav-open" for="nav-input"><span></span></div>
<div class="logo"><a href="./index.html"></a></div>
<div class="search-form"><form action="30_search.html" method="get" class="apisearch">
<input type="text" name="q" placeholder="搜索手册..." autosave="Unity Reference" results="5" class="sbox field" id="q"><input type="submit" class="submit">
</form></div>
<ul class="menu-items">
<li class="menu-item"><a href="../Manual/index.html" class="selected">手册</a></li>
<li class="menu-item"><a href="../ScriptReference/index.html" class="">脚本 API</a></li>
</ul>
</div></div>
<div class="more">
<div class="filler"></div>
<ul><li><a href="https://unity3d.com/">
                unity3d.com
              </a></li></ul>
</div>
</div></div>
<div class="toolbar"><div class="content">
<div class="version-switcher">
<div class="current toggle" data-target=".version-list"><div class="version-number">
<div class="d-inline-block">
          Version:
          <b>2019.4</b>
</div>
<div class="d-inline-block arrow"></div>
</div></div>
<div class="version-list" style="display:none;">
<ul class="versions">
<li class="supported"><a class="docs_version_url_2021.1" href="/cn/2021.1/Manual/ManagedCodeStripping.html">2021.1</a></li>
<li class="supported"><a class="docs_version_url_2020.3" href="/cn/2020.3/Manual/ManagedCodeStripping.html">2020.3</a></li>
<li class=""><a class="docs_version_url_2020.2" href="/cn/2020.2/Manual/ManagedCodeStripping.html">2020.2</a></li>
<li class=""><a class="docs_version_url_2020.1" href="/cn/2020.1/Manual/ManagedCodeStripping.html">2020.1</a></li>
<li class="supported"><a class="docs_version_url_2019.4" href="/cn/2019.4/Manual/ManagedCodeStripping.html">2019.4</a></li>
<li class=""><a class="docs_version_url_2019.3" href="/cn/2019.3/Manual/ManagedCodeStripping.html">2019.3</a></li>
<li class=""><a class="docs_version_url_2019.2" href="/cn/2019.2/Manual/ManagedCodeStripping.html">2019.2</a></li>
<li class=""><a class="docs_version_url_2019.1" href="/cn/2019.1/Manual/ManagedCodeStripping.html">2019.1</a></li>
<li class="supported"><a class="docs_version_url_2018.4" href="/cn/2018.4/Manual/ManagedCodeStripping.html">2018.4</a></li>
<li class=""><a class="docs_version_url_2018.3" href="/cn/2018.3/Manual/ManagedCodeStripping.html">2018.3</a></li>
<li class=""><a class="docs_version_url_2018.2" href="/cn/2018.2/Manual/ManagedCodeStripping.html">2018.2</a></li>
<li class=""><a class="docs_version_url_2018.1" href="/cn/2018.1/Manual/ManagedCodeStripping.html">2018.1</a></li>
<li class=""><a class="docs_version_url_2017.4" href="/cn/2017.4/Manual/ManagedCodeStripping.html">2017.4</a></li>
<li class=""><a class="docs_version_url_2017.3" href="/cn/2017.3/Manual/ManagedCodeStripping.html">2017.3</a></li>
<li class=""><a class="docs_version_url_2017.2" href="/cn/2017.2/Manual/ManagedCodeStripping.html">2017.2</a></li>
<li class=""><a class="docs_version_url_2017.1" href="/cn/2017.1/Manual/ManagedCodeStripping.html">2017.1</a></li>
<li class=""><a class="docs_version_url_560" href="/cn/560/Manual/ManagedCodeStripping.html">5.6</a></li>
<div class="versionsWithThisPage" style="display:none;"><li><p>包含此页的版本：</p></li></div>
<div class="versionsWithoutThisPage" style="display:none;"><li><p>不含此页的版本：</p></li></div>
</ul>
<ul class="description">
<li>
<div class="supported-box"></div>受支持</li>
<li>
<div class="legacy-box"></div>旧版</li>
</ul>
</div>
</div>
<ul class="nav-menu-items">
<li class="menu-item"><a href="../Manual/index.html" class="selected">手册</a></li>
<li class="menu-item"><a href="../ScriptReference/index.html" class="">脚本 API</a></li>
</ul>
<div class="lang-switcher">
<div class="current toggle" data-target=".lang-list">
<div class="lbl">语言:
        <span class="b">中文</span>
</div>
<div class="arrow"></div>
</div>
<div class="lang-list" style="display:none;"><ul>
<li><a data-lang="en" href="/2019.4/Documentation/Manual/ManagedCodeStripping.html">English</a></li>
<li><a data-lang="cn" href="/cn/2019.4/Manual/ManagedCodeStripping.html">中文</a></li>
<li><a data-lang="ja" href="/ja/2019.4/Manual/ManagedCodeStripping.html">日本語</a></li>
<li><a data-lang="es" href="/es/2019.4/Manual/ManagedCodeStripping.html">Español</a></li>
<li><a data-lang="kr" href="/kr/2019.4/Manual/ManagedCodeStripping.html">한국어</a></li>
<li><a data-lang="ru" href="/ru/2019.4/Manual/ManagedCodeStripping.html">Русский</a></li>
</ul></div>
</div>
</div></div>
</div>
<div id="master-wrapper" class="master-wrapper clear">
<div id="sidebar" class="sidebar hidden"><div class="sidebar-wrap"><div class="content"><div class="sidebar-menu"><div class="toc">
<h2>手册</h2>
<div class="version-switcher">
<div class="current toggle" data-target=".version-list"><div class="version-number">
<div class="d-inline-block">
          Version:
          <b>2019.4</b>
</div>
<div class="d-inline-block arrow"></div>
</div></div>
<div class="version-list" style="display:none;">
<ul class="versions">
<li class="supported"><a class="docs_version_url_2021.1" href="/cn/2021.1/Manual/ManagedCodeStripping.html">2021.1</a></li>
<li class="supported"><a class="docs_version_url_2020.3" href="/cn/2020.3/Manual/ManagedCodeStripping.html">2020.3</a></li>
<li class=""><a class="docs_version_url_2020.2" href="/cn/2020.2/Manual/ManagedCodeStripping.html">2020.2</a></li>
<li class=""><a class="docs_version_url_2020.1" href="/cn/2020.1/Manual/ManagedCodeStripping.html">2020.1</a></li>
<li class="supported"><a class="docs_version_url_2019.4" href="/cn/2019.4/Manual/ManagedCodeStripping.html">2019.4</a></li>
<li class=""><a class="docs_version_url_2019.3" href="/cn/2019.3/Manual/ManagedCodeStripping.html">2019.3</a></li>
<li class=""><a class="docs_version_url_2019.2" href="/cn/2019.2/Manual/ManagedCodeStripping.html">2019.2</a></li>
<li class=""><a class="docs_version_url_2019.1" href="/cn/2019.1/Manual/ManagedCodeStripping.html">2019.1</a></li>
<li class="supported"><a class="docs_version_url_2018.4" href="/cn/2018.4/Manual/ManagedCodeStripping.html">2018.4</a></li>
<li class=""><a class="docs_version_url_2018.3" href="/cn/2018.3/Manual/ManagedCodeStripping.html">2018.3</a></li>
<li class=""><a class="docs_version_url_2018.2" href="/cn/2018.2/Manual/ManagedCodeStripping.html">2018.2</a></li>
<li class=""><a class="docs_version_url_2018.1" href="/cn/2018.1/Manual/ManagedCodeStripping.html">2018.1</a></li>
<li class=""><a class="docs_version_url_2017.4" href="/cn/2017.4/Manual/ManagedCodeStripping.html">2017.4</a></li>
<li class=""><a class="docs_version_url_2017.3" href="/cn/2017.3/Manual/ManagedCodeStripping.html">2017.3</a></li>
<li class=""><a class="docs_version_url_2017.2" href="/cn/2017.2/Manual/ManagedCodeStripping.html">2017.2</a></li>
<li class=""><a class="docs_version_url_2017.1" href="/cn/2017.1/Manual/ManagedCodeStripping.html">2017.1</a></li>
<li class=""><a class="docs_version_url_560" href="/cn/560/Manual/ManagedCodeStripping.html">5.6</a></li>
<div class="versionsWithThisPage" style="display:none;"><li><p>包含此页的版本：</p></li></div>
<div class="versionsWithoutThisPage" style="display:none;"><li><p>不含此页的版本：</p></li></div>
</ul>
<ul class="description">
<li>
<div class="supported-box"></div>受支持</li>
<li>
<div class="legacy-box"></div>旧版</li>
</ul>
</div>
</div>
<div class="clear"></div>
</div></div></div></div></div>
<div id="content-wrap" class="content-wrap opened-sidebar"><div class="content-block"><div class="content">
<div class="section">
<div class="breadcrumbs clear"><ul>
<li><a href="UnityManual.html">Unity 用户手册 (2019.4 LTS)</a></li>
<li><a href="ScriptingSection.html">脚本</a></li>
<li><a href="ScriptingConcepts.html">脚本概述</a></li>
<li>托管代码剥离</li>
</ul></div>
<div class="mb20"><div class="nextprev clear">
<div class="icon tt left mr1" data-distance="-40|-30|top">
<span class="prev"><a href="class-AssemblyDefinitionImporter.html"></a></span><div class="tip">程序集定义 (Assembly Definition) 属性</div>
</div>
<div class="icon tt right" data-distance="-40|-30|top">
<span class="next"><a href="dotnetProfileSupport.html"></a></span><div class="tip">.NET 配置文件支持</div>
</div>
</div></div>
<h1>托管代码剥离</h1>
<!--BeginSwitchLink--><!--EndSwitchLink-->
<div class="clear"></div>

<p>托管代码剥离将从构建中删除未使用的代码，从而可以显著减小最终构建大小。使用 IL2CPP 脚本后端时，托管代码剥离还可以减少构建时间，因为需要转换为 C++ 并进行编译的代码减少。托管代码剥离将从托管程序集（包括从项目中的 C# 脚本构建的程序集、包含在包和插件中的程序集以及 .NET 框架中的程序集）中删除代码。</p>

<p>托管代码剥离的工作方式是对项目中的代码进行静态分析，检测出在执行过程中永远无法访问的类、类成员甚至函数的某些部分。可以通过 <strong>Player Settings</strong> 窗口中的 <strong>Managed Stripping Level</strong> 设置（在 <strong>Optimization</strong> 部分）来控制 Unity 删除无法访问的代码的激进程度。</p>

<p>__重要信息：__当代码（或插件中的代码）使用反射来动态查找类或成员时，代码剥离工具不能总是检测出项目是否正在使用这些类或成员，因此可能会删除它们。要声明某个项目正在使用这样的代码，请使用 <a href="#LinkXML">link.xml 文件</a>或 <a href="#PreserveAttribute">Preserve</a> 属性。</p>

<p><a name="ManagedStrippingLevels"></a></p>

<h2>托管剥离级别</h2>

<p>使用项目的 <strong>Player Settings</strong> 中的 <strong>Managed Stripping Level</strong> 选项来控制 Unity 删除未使用代码的激进程度。</p>

<figure>
<img src="../uploads/Main/mgc_StripLevel.png" alt="Managed Stripping Level 设置">
<figcaption>Managed Stripping Level 设置</figcaption>
</figure>

<p><strong>注意：__此选项的默认值根据 </strong>Scripting Backend__ 的当前设置而不同。</p>

<table>
<colgroup>
<col style="text-align:left;">
<col style="text-align:left;">
</colgroup>

<thead>
<tr>
	<th style="text-align:left;"><strong>属性</strong></th>
	<th style="text-align:left;"><strong>功能</strong></th>
</tr>
</thead>

<tbody>
<tr>
	<td style="text-align:left;"><strong>Disabled</strong></td>
	<td style="text-align:left;">不删除代码。<br><br>此选项是 Mono 脚本后端的默认剥离级别。当选择 IL2CPP 脚本后端时，由于其对构建时间的影响，Disabled 选项不可用。托管代码越多意味着 IL2CPP 要生成的 C++ 代码越多，也意味着需要编译的 C++ 代码越多。导致的结果是，从进行代码更改到看到更改生效所间隔的时间大幅增加。</td>
</tr>
<tr>
	<td style="text-align:left;"><strong>Low</strong></td>
	<td style="text-align:left;">根据一组保守的规则删除代码，因此应该会删除大多数无法访问的代码，同时尽量降低实际使用的代码被剥离的可能性。剥离级别低有利于确保可用性，但不利于减小代码大小。<br><br>此选项是 IL2CPP 的默认剥离级别（并且已用于 Unity Editor 的许多发行版）。</td>
</tr>
<tr>
	<td style="text-align:left;"><strong>Medium</strong></td>
	<td style="text-align:left;">根据一组规则删除代码，确保在低 (Low) 剥离级别和高 (High) 剥离级别之间取得平衡。中等 (Medium) 剥离级别不像低剥离级别那么谨慎，也不如高剥离级别那么极端。因此，因删除代码而导致意外副作用的风险大于低剥离级别，但小于高剥离级别。<br><br>如果将中等剥离级别用于 IL2CPP 脚本后端，可进一步缩短代码更改与测试之间的迭代时间。<br><br>使用 .NET 3.5 脚本运行时版本 (.NET 3.5 Scripting Runtime Version) 设置时，中等剥离级别不可用。</td>
</tr>
<tr>
	<td style="text-align:left;"><strong>High</strong></td>
	<td style="text-align:left;">尽可能删除无法访问的代码，并生成比中等 (Medium) 剥离级别更小的构建。高 (High) 剥离级别优先考虑减小代码大小，而不是确保可用性；您可能需要添加 link.xml 文件、Preserve 属性或重写有问题的代码部分。<br><br>高剥离级别会执行更耗时的分析，以进一步减小大小，因此构建和迭代时间可能比中等剥离级别下的时间更长。<br><br>当使用 .NET 3.5 脚本运行时版本 (.NET 3.5 Scripting Runtime Version) 设置时，高剥离级别不可用。</td>
</tr>
</tbody>
</table>

<p><strong>注意__：__Managed Stripping Level</strong> 选项不会影响删除未使用 Unity 引擎代码的过程（使用 <strong>IL2CPP Scripting Backend</strong> 设置时可用）。</p>

<h1>了解托管代码剥离</h1>

<p>本部分介绍托管代码剥离的详细信息，以及如何识别和纠正可能出现的任何相关问题。</p>

<p>在 Unity 中构建项目时，构建过程将 C# 代码编译为称为公共中间语言 (CIL) 的 .NET 字节码格式。此 CIL 字节码被打包到称为程序集的文件中。同样，.NET 框架库以及在项目中使用的插件中的所有 C# 库也都会预先打包为 CIL 字节码的程序集。通常，无论项目使用程序集的多少代码，构建过程始终包括整个程序集文件。</p>

<p>托管代码剥离过程将分析项目中的程序集，以查找和删除未实际使用的代码。分析过程使用一组规则来确定要保留的代码和要丢弃的代码。这些规则将在构建大小（包含太多代码）与风险（删除太多代码）之间进行权衡。<a href="#ManagedStrippingLevels">Managed Stripping Level</a> 设置可用于控制删除代码的激进程度。</p>

<h2>UnityLinker</h2>

<p>Unity 构建过程使用一个名为 <em>UnityLinker</em> 的工具来剥离托管代码。UnityLinker 是 <a href="https://github.com/mono/linker">Mono IL Linker</a> 的一个定制版本，专为 Unity 设计。UnityLinker 基于我们的项目<a href="https://github.com/Unity-Technologies/linker">分叉</a>，此分叉密切跟踪上游 IL Linker 项目。（请注意，该分叉中未维护 UnityLinker 的 Unity 引擎特有自定义部分。）</p>

<h3>UnityLinker 的工作方式</h3>

<p>UnityLinker 将分析项目中的所有程序集。首先标记顶级、根类型、方法、属性、字段等，例如，向场景中的游戏对象添加的 MonoBehaviour 派生类便是根类型。然后，UnityLinker 分析已标记为要进行识别的根，并标记这些根所依赖的托管代码。完成此静态分析后，所有剩余的未标记代码都无法通过应用程序代码中的任何执行路径来访问，并将从程序集中删除。</p>

<p>请注意，这一过程不会对代码进行混淆处理。</p>

<h2>反射和代码剥离</h2>

<p>UnityLinker 不能总是检测出项目中的代码通过<a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/reflection">反射</a>时来引用其他代码的实例，因此可能会误删除实际在使用的代码。将 <strong>Managed Stripping Level</strong> 设置从 <strong>Low</strong> 提升为 <strong>High</strong> 时，代码剥离导致游戏中发生意外行为变化的风险也会增加。这种行为变化小到细微的逻辑变化，大到调用缺失方法造成的崩溃。</p>

<p>UnityLinker 能够检测和处理一些反射模式。如需查看该工具可以处理的最新模式的示例，请参阅 Mono IL Linker <a href="https://github.com/mono/linker/tree/master/linker/Tests/Mono.Linker.Tests.Cases/Reflection">反射测试套件</a>。但是，如果使用的不仅仅是简单的反射，必须给 UnityLinker 一些提示，说明哪些类不应该被处理。可以通过 <strong>link.xml</strong> 文件和 <strong>Preserve</strong> 属性的形式提供这些提示：</p>

<ul>
<li>Preserve 属性 — 直接在源代码中标记要保留的元素。</li>
<li>link.xml 文件 — 声明应如何保留程序集中的元素。</li>
</ul>

<p>UnityLinker 在分析程序集中未使用的代码时，会将使用属性或 link.xml 文件保留的每个元素视为根元素。</p>

<p><a name="PreserveAttribute"></a></p>

<h3>Preserve 属性</h3>

<p>在源代码中使用 [<a href="../ScriptReference/Scripting.PreserveAttribute.html">Preserve</a>] 属性可防止 UnityLinker 剥离该代码。下面的列表描述了在对不同的代码元素应用 Preserve 属性时 UnityLinker 会保留哪些实体：</p>

<ul>
<li>
<p>__Assembly__：保留程序集内的所有类型（就好像您为每个类型输入了 [Preserve] 属性一样）。要为程序集分配 Preserve 属性，请将该属性声明放在程序集包含的任何 C# 文件中，但需在所有命名空间声明之外：</p>

<pre><code>using System;
  using UnityEngine.Scripting;

  [assembly: Preserve]

  namespace Example
  {
      public class Foo {}
  }
</code></pre>
</li>
<li><p>__Type__：保留类型及其默认构造函数。</p></li>
<li><p>__Method__：保留方法、其声明类型、返回类型及其所有参数的类型。</p></li>
<li><p>__Property__：保留属性、其声明类型、值类型、getter 方法以及 setter 方法。</p></li>
<li><p>__Field__：保留字段、其声明类型和字段类型。</p></li>
<li><p>__Event__：保留事件、其声明类型、返回类型、add 方法以及 remove 方法。</p></li>
<li><p>__Delegate__：保留委派类型及其所有方法。</p></li>
</ul>

<p>请注意，相比使用 Preserve 属性，在 link.xml 文件中标记代码实体可以提供更强的控制。例如，用 Preserve 属性修饰某个类既会保留类型，也会保留默认构造函数。而使用 link.xml 文件，可以选择只保留类型（不保留默认构造函数）。</p>

<p>可以在任何程序集中和任何命名空间中定义 Preserve 属性。因此，可以使用 UnityEngine.Scripting.PreserveAttribute 类、为其创建子类或创建您自己的 <a href="../ScriptReference/PreserveAttribute.html">PreserveAttribute</a> 类，例如：</p>

<pre><code>class Foo
{
    [UnityEngine.Scripting.Preserve]
    public void UsingUnityPreserve(){}

    [CustomPreserve]
    public void UsingCustomPreserve(){}

    [Preserve]
    public void UsingOwnPreserve(){}
}

class CustomPreserveAttribute : UnityEngine.Scripting.PreserveAttribute {}

class PreserveAttribute : System.Attribute {}
</code></pre>

<h3>AlwaysLinkAssembly 属性</h3>

<p>使用 [assembly: UnityEngine.Scripting.AlwaysLinkAssembly] 属性可强制 UnityLinker 处理程序集（无论程序集是否被构建中包含的另一个程序集引用）。<a href="../ScriptReference/Scripting.AlwaysLinkAssemblyAttribute.html">AlwaysLinkAssembly</a> 属性只能在程序集上定义。</p>

<p>此属性仅指示 UnityLinker 将其__根标记规则 (Root Marking Rules)__ 应用于程序集。该属性本身不会直接使程序集中的代码被保留。如果没有代码元素与程序集的根标记规则匹配，UnityLinker 仍会从构建中删除程序集。</p>

<p>可在包含一个或多个方法的包或预编译程序集上将此属性与 [RuntimeInitializeOnLoadMethod] 属性结合使用，但后者可能不包含在项目的任何场景中直接或间接使用的类型。</p>

<p>如果程序集定义 [assembly: AlwaysLinkAssembly] 属性并由构建中包含的其他程序集所引用，则该属性对于输出没有任何影响。</p>

<p><a name="LinkXML"></a></p>

<h3>Link XML</h3>

<p>link.xml 文件是一个基于项目的列表，其中声明如何保留程序集以及程序集中的类型和其他代码实体。要使用 link.xml 文件，请创建此文件（请参阅下面的示例），并将其放入项目的 Assets 文件夹（或者 Assets 文件夹的任何子目录）。可以在项目中使用任意数量的 link.xml 文件，因此插件可以提供自己的保留声明。UnityLinker 会将 link.xml 文件中保留的任何程序集、类型或成员都视为根类型。</p>

<p>请注意，在软件包中不支持 link.xml 文件，但可以从非软件包 link.xml 文件中引用软件包程序集。</p>

<p>以下示例说明了使用 link.xml 文件声明项目程序集的根类型时可以采用的不同方式：</p>

<pre><code class="xml">
&lt;linker&gt;
  &lt;!--
  Preserve types and members in an assembly
  --&gt;
  &lt;assembly fullname="Assembly1"&gt;
    &lt;!--Preserve an entire type--&gt;
    &lt;type fullname="Assembly1.A" preserve="all"/&gt;

    &lt;!--No "preserve" attribute and no members specified 
        means preserve all members--&gt;
    &lt;type fullname="Assembly1.B"/&gt;

    &lt;!--Preserve all fields on a type--&gt;
    &lt;type fullname="Assembly1.C" preserve="fields"/&gt;

    &lt;!--Preserve all fields on a type--&gt;
    &lt;type fullname="Assembly1.D" preserve="methods"/&gt;

    &lt;!--Preserve the type only--&gt;
    &lt;type fullname="Assembly1.E" preserve="nothing"/&gt;

    &lt;!--Preserving only specific members of a type--&gt;
    &lt;type fullname="Assembly1.F"&gt;
        
      &lt;!--
      Fields
      --&gt;
      &lt;field signature="System.Int32 field1" /&gt;

      &lt;!--Preserve a field by name rather than signature--&gt;
      &lt;field name="field2" /&gt;
      
      &lt;!--
      Methods
      --&gt;
      &lt;method signature="System.Void Method1()" /&gt;

      &lt;!--Preserve a method with parameters--&gt;
      &lt;method signature="System.Void Method2(System.Int32,System.String)" /&gt;

      &lt;!--Preserve a method by name rather than signature--&gt;
      &lt;method name="Method3" /&gt;

      &lt;!--
      Properties
      --&gt;

      &lt;!--Preserve a property, it's backing field (if present), 
          getter, and setter methods--&gt;
      &lt;property signature="System.Int32 Property1" /&gt;

      &lt;property signature="System.Int32 Property2" accessors="all" /&gt;

      &lt;!--Preserve a property, it's backing field (if present), and getter method--&gt;
      &lt;property signature="System.Int32 Property3" accessors="get" /&gt;

      &lt;!--Preserve a property, it's backing field (if present), and setter method--&gt;
      &lt;property signature="System.Int32 Property4" accessors="set" /&gt;

      &lt;!--Preserve a property by name rather than signature--&gt;
      &lt;property name="Property5" /&gt;

      &lt;!--
      Events
      --&gt;

      &lt;!--Preserve an event, it's backing field (if present), 
          add, and remove methods--&gt;
      &lt;event signature="System.EventHandler Event1" /&gt;

      &lt;!--Preserve an event by name rather than signature--&gt;
      &lt;event name="Event2" /&gt;

    &lt;/type&gt;

    &lt;!--Examples with generics--&gt;
    &lt;type fullname="Assembly1.G`1"&gt;

      &lt;!--Preserve a field with generics in the signature--&gt;
      &lt;field signature="System.Collections.Generic.List`1&amp;lt;System.Int32&amp;gt; field1" /&gt;

      &lt;field signature="System.Collections.Generic.List`1&amp;lt;T&amp;gt; field2" /&gt;

      &lt;!--Preserve a method with generics in the signature--&gt;
      &lt;method signature="System.Void Method1(System.Collections.Generic.List`1&amp;lt;System.Int32&amp;gt;)" /&gt;

      &lt;!--Preserve an event with generics in the signature--&gt;
      &lt;event signature="System.EventHandler`1&amp;lt;System.EventArgs&amp;gt; Event1" /&gt;

    &lt;/type&gt;

    &lt;!--Preserve a nested type--&gt;
    &lt;type fullname="Assembly1.H/Nested" preserve="all"/&gt;

    &lt;!--Preserve all fields of a type if the type is used.  If the type is not 
        used it will be removed--&gt;
    &lt;type fullname="Assembly1.I" preserve="fields" required="0"/&gt;

    &lt;!--Preserve all methods of a type if the type is used.  
        If the type is not used it will be removed--&gt;
    &lt;type fullname="Assembly1.J" preserve="methods" required="0"/&gt;

    &lt;!--Preserve all types in a namespace--&gt;
    &lt;type fullname="Assembly1.SomeNamespace*" /&gt;

    &lt;!--Preserve all types with a common prefix in their name--&gt;
    &lt;type fullname="Prefix*" /&gt;

  &lt;/assembly&gt;
  
  &lt;!--Preserve an entire assembly--&gt;
  &lt;assembly fullname="Assembly2" preserve="all"/&gt;

  &lt;!--No "preserve" attribute and no types specified means preserve all--&gt;
  &lt;assembly fullname="Assembly3"/&gt;

  &lt;!--Fully qualified assembly name--&gt;
  &lt;assembly fullname="Assembly4, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null"&gt;
    &lt;type fullname="Assembly4.Foo" preserve="all"/&gt;
  &lt;/assembly&gt;

  &lt;!--Force an assembly to be processed for roots but don’t explicitly preserve 
      anything in particular.  Useful when the assembly is not referenced.--&gt;
  &lt;assembly fullname="Assembly5" preserve="nothing"/&gt;

&lt;/linker&gt;
</code></pre>

<h4>特殊程序集 XML 属性</h4>

<p>link.xml 文件的 &lt;assembly&gt; 元素有三个特殊用途的属性：</p>

<ul>
<li>
<p><strong>ignoreIfMissing</strong>
默认情况下，如果找不到 link.xml 文件中引用的程序集，那么 UnityLinker 将中止构建。如果需要声明在所有播放器构建过程中不存在的程序集的保留，请在 link.xml 文件中的 &lt;assembly&gt; 元素上使用 ignoreIfMissing 属性：</p>

<pre><code class="xml">&lt;linker&gt;
  &lt;assembly fullname="Foo" ignoreIfMissing="1"&gt;
    &lt;type name="Type1"/&gt;
  &lt;/assembly&gt;
&lt;/linker&gt;
</code></pre>
</li>
<li>
<p><strong>ignoreIfUnreferenced</strong></p>

<p>在某些情况下，您可能希望仅当程序集被其他程序集引用时才保留程序集中的实体。可以在 link.xml 文件中的 &lt;assembly&gt; 元素上使用 ignoreIfUnreferenced 属性，这样仅当程序集中引用至少一种类型时才保留程序集中的实体。</p>

<pre><code class="xml">&lt;linker&gt;
  &lt;assembly fullname="Bar" ignoreIfUnreferenced="1"&gt;
    &lt;type name="Type2"/&gt;
  &lt;/assembly&gt;
&lt;/linker&gt;
</code></pre>

<p>__注意：__进行引用的程序集中的代码本身是否被剥离并不重要，被引用的程序集中具有此属性的指定元素仍会被保留。</p>
</li>
<li>
<p><strong>windowsruntime</strong></p>

<p>为 Windows 运行时元数据 (.winmd) 程序集定义保留时，必须在 link.xml 文件中的 &lt;assembly&gt; 元素中添加 windowsruntime=“true” 属性：</p>

<pre><code class="xml">&lt;linker&gt;
  &lt;assembly fullname="Windows" windowsruntime="true"&gt;
    &lt;type name="Type3"/&gt;
  &lt;/assembly&gt;
&lt;/linker&gt;
</code></pre>
</li>
</ul>

<h2>UnityLinker 剥离程序集的方式</h2>

<p>Unity Editor 会将包含 Unity 项目任何场景使用的类型的程序集列表进行合并，并将其传递给 UnityLinker。然后，UnityLinker 处理这些程序集、这些程序集的任何引用、link.xml 文件中声明的任何程序集以及具有 AlwaysLinkAssembly 属性的任何程序集。通常，项目中不属于这些类别的任何程序集都不会被 UnityLinker 处理，也不会包含在播放器构建中。</p>

<p>UnityLinker 在处理每个程序集时遵循一组规则，这组规则基于程序集分类，程序集是否包含场景中使用的类型，以及为构建选择的 <strong>Managed Stripping Level</strong> 属性值。</p>

<p>根据这些规则的用途，程序集划为以下几种分类：</p>

<ul>
<li><p><strong>.NET 类库程序集</strong> — 包括 Mono 类库（如 mscorlib.dll 和 System.dll）以及 .NET 类库外观程序集（如 netstandard.dll）。</p></li>
<li><p><strong>平台 SDK 程序集</strong> — 包括特定于平台 SDK 的托管程序集。例如，通用 Windows 平台 SDK 中包含的 windows.winmd 程序集。</p></li>
<li><p><strong>Unity 引擎模块程序集</strong> — 包括构成 Unity 引擎的托管程序集，如 UnityEngine.Core.dll。</p></li>
<li>
<p><strong>项目程序集</strong> — 包括特定于项目的程序集，例如：</p>

<ul>
<li><p>脚本程序集，如 Assembly-CSharp.dll</p></li>
<li><p>预编译的程序集</p></li>
<li><p><a href="ScriptCompilationAssemblyDefinitionFiles.html">程序集定义程序集</a></p></li>
<li><p>软件包程序集</p></li>
</ul>
</li>
</ul>

<p>以下各节将详细介绍 UnityLinker 如何针对每种 <strong>Managed Stripping Level</strong> 设置进行标记以及保留或剥离程序集代码：</p>

<ul>
<li><a href="#LowStrippingLevel">低剥离级别</a></li>
<li><a href="#MediumStrippingLevel">中等剥离级别</a></li>
<li><a href="#HighStrippingLevel">高剥离级别</a></li>
</ul>

<p><a name="LowStrippingLevel"></a></p>

<h2>低剥离级别</h2>

<p>将 <strong>Managed Stripping Level</strong> 设置为 <strong>Low</strong> 时，UnityLinker 将根据一组保守的规则删除代码，因此应该会删除大多数无法访问的代码，同时尽量降低实际使用的代码被剥离的可能性。__低__剥离级别优先考虑可用性，其次才是减小代码大小。</p>

<h3>低剥离级别的根标记规则</h3>

<p>根标记规则决定了 UnityLinker 如何识别程序集中的顶级类型。</p>

<table>
<colgroup>
<col style="text-align:left;">
<col style="text-align:left;">
<col style="text-align:left;">
</colgroup>

<thead>
<tr>
	<th style="text-align:left;"><strong>程序集类型</strong></th>
	<th style="text-align:left;"><strong>操作</strong></th>
	<th style="text-align:left;"><strong>根标记规则</strong></th>
</tr>
</thead>

<tbody>
<tr>
	<td style="text-align:left;">.NET 类和平台 SDK</td>
	<td style="text-align:left;">剥离</td>
	<td style="text-align:left;">应用预防性保留</td>
</tr>
<tr>
	<td style="text-align:left;"></td>
	<td style="text-align:left;"></td>
	<td style="text-align:left;">任何 link.xml 中定义的保留</td>
</tr>
<tr>
	<td style="text-align:left;">包含场景中所用类型的程序集</td>
	<td style="text-align:left;">复制</td>
	<td style="text-align:left;">标记程序集中的所有类型和成员</td>
</tr>
<tr>
	<td style="text-align:left;">其他全部</td>
	<td style="text-align:left;">剥离</td>
	<td style="text-align:left;">标记所有公共类型</td>
</tr>
<tr>
	<td style="text-align:left;"></td>
	<td style="text-align:left;"></td>
	<td style="text-align:left;">标记公共类型的所有公共成员</td>
</tr>
<tr>
	<td style="text-align:left;"></td>
	<td style="text-align:left;"></td>
	<td style="text-align:left;">标记包含 [RuntimeInitializeOnLoadMethod] 属性的方法</td>
</tr>
<tr>
	<td style="text-align:left;"></td>
	<td style="text-align:left;"></td>
	<td style="text-align:left;">标记包含 [Preserve] 属性的类型和成员</td>
</tr>
<tr>
	<td style="text-align:left;"></td>
	<td style="text-align:left;"></td>
	<td style="text-align:left;">任何 link.xml 中定义的保留</td>
</tr>
<tr>
	<td style="text-align:left;"></td>
	<td style="text-align:left;"></td>
	<td style="text-align:left;">在下列程序集中标记派生自 MonoBehaviour 和 ScriptableObject 的所有类型：<br><br>预编译程序集<br><br>软件包程序集<br><br>程序集定义程序集<br><br>Unity 脚本程序集</td>
</tr>
<tr>
	<td style="text-align:left;">测试</td>
	<td style="text-align:left;">剥离</td>
	<td style="text-align:left;">标记包含 NUnit.Framework 中定义的任何属性的方法。例如：[Test]</td>
</tr>
<tr>
	<td style="text-align:left;"></td>
	<td style="text-align:left;"></td>
	<td style="text-align:left;">标记包含 [UnityTest] 属性的方法</td>
</tr>
</tbody>
</table>

<p><strong>注意：____剥离__操作意味着 UnityLinker 会分析程序集来找出可以删除的代码。</strong>复制__操作意味着 UnityLinker 可将整个程序集复制到最终构建（并且将其中的所有类型都标记为根类型）。</p>

<h3>低剥离级别的依赖项标记规则</h3>

<p>标记根类型后，UnityLinker 将执行静态分析以识别这些根所依赖的所有代码。</p>

<table>
<colgroup>
<col style="text-align:left;">
<col style="text-align:left;">
</colgroup>

<thead>
<tr>
	<th style="text-align:left;"><strong>规则目标</strong></th>
	<th style="text-align:left;"><strong>描述</strong></th>
</tr>
</thead>

<tbody>
<tr>
	<td style="text-align:left;">Unity 类型</td>
	<td style="text-align:left;">当 UnityLinker 标记派生自 MonoBehaviour 的类型时，还会标记该类型的所有成员。</td>
</tr>
<tr>
	<td style="text-align:left;"></td>
	<td style="text-align:left;">当 UnityLinker 标记派生自 ScriptableObject 的类型时，还会标记该类型的所有成员。</td>
</tr>
<tr>
	<td style="text-align:left;">特性</td>
	<td style="text-align:left;">UnityLinker 在所有标记的程序集、类型、方法、字段、属性等对象中标记相应属性。</td>
</tr>
<tr>
	<td style="text-align:left;">调试属性</td>
	<td style="text-align:left;">启用脚本调试时，UnityLinker 将标记具有 [DebuggerDisplay] 属性的所有成员（即使没有代码路径使用该成员）。</td>
</tr>
<tr>
	<td style="text-align:left;">.NET 外观类库程序集</td>
	<td style="text-align:left;">外观程序集是指 .NET 类库中负责将类型定义转发给另一个程序集的程序集。例如，<code>netstandard.dll</code>（属于 .NET Standard 2.0 API 兼容性级别）就是一个外观程序集，它定义 .NET 接口，但将该接口的实现转发给其他 .NET 程序集。<br><br>外观程序集在运行时并不是严格必要的，但是，由于可以编写依赖这些程序集的反射代码，因此低剥离级别会保留这些程序集。</td>
</tr>
</tbody>
</table>

<h4>DebugDisplay 属性示例</h4>

<p>在下面的示例中，假设在代码中的任何地方都没有使用 <code>Foo.UnusedProperty</code> 属性。通常，UnityLinker 会剥离该属性，但当您启用脚本调试时，它将标记 <code>Foo.UnusedProperty</code> 并保留该属性，因为 [DebuggerDisplay] 属性在 <code>Foo</code> 中。</p>

<pre><code>[DebuggerDisplay("{UnusedProperty}")]
class Foo
{
    public int UnusedProperty { get; set; }
}
</code></pre>

<p><a name="MediumStrippingLevel"></a></p>

<h2>中等剥离级别</h2>

<p>将 <strong>Managed Stripping Level</strong> 设置为 <strong>Medium</strong> 时，UnityLinker 将根据一组规则删除代码，确保在__低 (Low)__ 剥离级别和__高 (High)__ 剥离级别之间取得平衡。<strong>中等 (Medium)</strong> 剥离级别不像__低__剥离级别那么谨慎，也不如__高__剥离级别那么极端。因此，因删除代码而导致意外副作用的风险大于__低__剥离级别，但小于__高__剥离级别。</p>

<h3>中等剥离级别的根标记规则</h3>

<table>
<colgroup>
<col style="text-align:left;">
<col style="text-align:left;">
<col style="text-align:left;">
</colgroup>

<thead>
<tr>
	<th style="text-align:left;"><strong>程序集类型</strong></th>
	<th style="text-align:left;"><strong>操作</strong></th>
	<th style="text-align:left;"><strong>根标记规则</strong></th>
</tr>
</thead>

<tbody>
<tr>
	<td style="text-align:left;">.NET 类和平台 SDK</td>
	<td style="text-align:left;">剥离</td>
	<td style="text-align:left;">与低剥离级别相同，但：不适用预防性保留</td>
</tr>
<tr>
	<td style="text-align:left;">包含场景中引用的类型的程序集</td>
	<td style="text-align:left;">剥离</td>
	<td style="text-align:left;">不自动标记程序集中的所有类型和成员</td>
</tr>
<tr>
	<td style="text-align:left;"></td>
	<td style="text-align:left;"></td>
	<td style="text-align:left;">标记包含 [RuntimeInitializeOnLoadMethod] 属性的方法</td>
</tr>
<tr>
	<td style="text-align:left;"></td>
	<td style="text-align:left;"></td>
	<td style="text-align:left;">标记包含 [Preserve] 属性的类型和成员</td>
</tr>
<tr>
	<td style="text-align:left;"></td>
	<td style="text-align:left;"></td>
	<td style="text-align:left;">任何 link.xml 中定义的保留</td>
</tr>
<tr>
	<td style="text-align:left;"></td>
	<td style="text-align:left;"></td>
	<td style="text-align:left;">在下列程序集中标记派生自 MonoBehaviour 和 ScriptableObject 的所有类型：<br><br>预编译程序集<br><br>软件包程序集<br><br>程序集定义程序集<br><br>Unity 脚本程序集</td>
</tr>
<tr>
	<td style="text-align:left;">其他全部</td>
	<td style="text-align:left;">剥离</td>
	<td style="text-align:left;">与低剥离级别相同，但：<br><br>不自动标记公共类型<br><br>不自动标记公共类型的公共成员</td>
</tr>
<tr>
	<td style="text-align:left;">测试</td>
	<td style="text-align:left;">剥离</td>
	<td style="text-align:left;">与低剥离级别相同</td>
</tr>
</tbody>
</table>

<h3>中等剥离级别的依赖项标记规则</h3>

<table>
<colgroup>
<col style="text-align:left;">
<col style="text-align:left;">
</colgroup>

<thead>
<tr>
	<th style="text-align:left;"><strong>规则目标</strong></th>
	<th style="text-align:left;"><strong>描述</strong></th>
</tr>
</thead>

<tbody>
<tr>
	<td style="text-align:left;">Unity 类型</td>
	<td style="text-align:left;">与低剥离级别相同</td>
</tr>
<tr>
	<td style="text-align:left;">特性</td>
	<td style="text-align:left;">与低剥离级别相同</td>
</tr>
<tr>
	<td style="text-align:left;">调试属性</td>
	<td style="text-align:left;">与低剥离级别相同</td>
</tr>
<tr>
	<td style="text-align:left;">.NET 外观类库程序集</td>
	<td style="text-align:left;">与低剥离级别相同</td>
</tr>
</tbody>
</table>

<p><a name="HighStrippingLevel"></a></p>

<h2>高剥离级别</h2>

<p>将 <strong>Managed Stripping Level</strong> 设置为 <strong>High</strong> 时，UnityLinker 将尽可能移除无法访问的代码，并生成比__中等 (Medium)__ 剥离级别更小的构建。<strong>高 (High)</strong> 剥离级别优先考虑减小代码大小，而不是确保可用性；您可能需要添加 link.xml 文件、<strong>Preserve</strong> 甚至重写有问题的代码部分。</p>

<h3>高剥离级别的根标记规则</h3>

<table>
<colgroup>
<col style="text-align:left;">
<col style="text-align:left;">
<col style="text-align:left;">
</colgroup>

<thead>
<tr>
	<th style="text-align:left;"><strong>程序集类型</strong></th>
	<th style="text-align:left;"><strong>操作</strong></th>
	<th style="text-align:left;"><strong>根标记规则</strong></th>
</tr>
</thead>

<tbody>
<tr>
	<td style="text-align:left;">.NET 类和平台 SDK</td>
	<td style="text-align:left;">剥离</td>
	<td style="text-align:left;">与中等剥离级别相同</td>
</tr>
<tr>
	<td style="text-align:left;">包含场景中引用的类型的程序集</td>
	<td style="text-align:left;">剥离</td>
	<td style="text-align:left;">与中等剥离级别相同</td>
</tr>
<tr>
	<td style="text-align:left;">其他全部</td>
	<td style="text-align:left;">剥离</td>
	<td style="text-align:left;">与中等剥离级别相同</td>
</tr>
<tr>
	<td style="text-align:left;">测试</td>
	<td style="text-align:left;">剥离</td>
	<td style="text-align:left;">与低剥离级别相同</td>
</tr>
</tbody>
</table>

<h4>Link XML 功能标签排除项</h4>

<p><a href="#LinkXML">Link.xml</a> 文件支持不常使用的 “features” XML 属性。例如，mscorlib.dll 中嵌入的 mscorlib.xml 文件使用此属性，但在适当情况下，您可以在任何 link.xml 文件中使用该属性。</p>

<p>在__高__级别剥离期间，UnityLinker 根据当前构建的设置来排除不支持的功能的保留：</p>

<ul>
<li>remoting — 以 IL2CPP 脚本后端作为目标时排除。</li>
<li>sre — 以 IL2CPP 脚本后端作为目标时排除。</li>
<li>com — 以不支持 COM 的平台作为目标时排除。</li>
</ul>

<p>例如，下面的 link.xml 文件在支持 COM 的平台上保留某种类型的一个方法，并在所有平台上保留一个方法：</p>

<pre><code class="xml">
&lt;linker&gt;
    &lt;assembly fullname="Foo"&gt;
        &lt;type fullname="Type1"&gt;
            &lt;!--Preserve FeatureOne on platforms that support COM--&gt;
            &lt;method signature="System.Void FeatureOne()" feature="com"/&gt;
            &lt;!--Preserve FeatureTwo on all platforms--&gt;
            &lt;method signature="System.Void FeatureTwo()"/&gt;
        &lt;/type&gt;
    &lt;/assembly&gt;
&lt;/linker&gt;

</code></pre>

<h3>高剥离级别的依赖项标记规则</h3>

<table>
<colgroup>
<col style="text-align:left;">
<col style="text-align:left;">
</colgroup>

<thead>
<tr>
	<th style="text-align:left;"><strong>规则目标</strong></th>
	<th style="text-align:left;"><strong>描述</strong></th>
</tr>
</thead>

<tbody>
<tr>
	<td style="text-align:left;">Unity 类型</td>
	<td style="text-align:left;">与低剥离级别相同</td>
</tr>
<tr>
	<td style="text-align:left;">特性</td>
	<td style="text-align:left;">在所有标记的程序集、类型和成员上，如果属性类型也已经被标记，那么 UnityLinker 将标记属性。<br><br>注意，UnityLinker 总是保留某些属性，因为运行时需要这些属性。<br><br>UnityLinker 从所有程序集、类型和成员中删除与安全性相关的属性（如 System.Security.Permissions.SecurityPermissionAttribute）。</td>
</tr>
<tr>
	<td style="text-align:left;">调试属性</td>
	<td style="text-align:left;">UnityLinker 会始终删除调试属性，如 DebuggerDisplayAttribute 和 DebuggerTypeProxyAttribute。</td>
</tr>
<tr>
	<td style="text-align:left;">.NET 外观类库程序集</td>
	<td style="text-align:left;">与保留所有 .NET 外观程序集的中低剥离级别不同，高剥离级别将删除所有外观，因为在运行时不需要它们。<br><br>在剥离后，以外观程序集存在为前提的反射代码将不起作用。</td>
</tr>
</tbody>
</table>

<h3>方法体的编辑</h3>

<p>设置__高__剥离级别时，UnityLinker 将编辑方法体，以进一步减小代码大小。本节总结了 UnityLinker 对方法体所做的一些值得注意的编辑。</p>

<p>UnityLinker 目前只编辑 .NET 类库程序集中的方法体。注意，在方法体编辑之后，程序集的源代码不再与程序集中经过编译的代码匹配，因此可能使调试变得更加困难。</p>

<h4>删除无法访问的分支</h4>

<p>UnityLinker 会删除用于检查 <code>System.Environment.OSVersion.Platform</code> 并且当前目标平台无法访问的 If 语句块。</p>

<h4>内联 - 仅限字段访问的方法</h4>

<p>对于获取或设置字段的方法调用，UnityLinker 会替换为直接字段访问。这种做法通常能够完全剥离方法，有助于降低大小。</p>

<p>如果目标是 Mono 后端，那么仅当方法的调用者获准直接访问字段（根据字段的可见性），UnityLinker 才会进行此更改。对于 IL2CPP，可见性规则不适用，因此 UnityLinker 会在适当情况下均进行此更改。</p>

<h4>内联 - 常量返回值方法</h4>

<p>UnityLinker 会对只返回常量值的方法调用进行内联。</p>

<p><a name="EmptyCalls"></a></p>

<h4>删除空的非返回调用</h4>

<p>UnityLinker 会删除内容为空以及返回类型为 <code>void</code> 的方法调用。</p>

<h4>删除空作用域</h4>

<p>UnityLinker 会在 Finally 块为空时删除 Try/Finally 模块。删除<a href="#EmptyCalls">空调用</a>可能会产生空的 Finally 块。在方法编辑过程中发生这种情况时，UnityLinker 将删除整个 Try/Finally 块。可能发生这种情况的一个情形是编译器在 foreach 循环中生成 Try/Finally 块来调用 <code>Dispose()</code>。</p>
<!-- area:core -->
<div class="nextprev clear">
<div class="icon tt left mr1" data-distance="-40|-30|top">
<span class="prev"><a href="class-AssemblyDefinitionImporter.html"></a></span><div class="tip">程序集定义 (Assembly Definition) 属性</div>
</div>
<div class="icon tt right" data-distance="-40|-30|top">
<span class="next"><a href="dotnetProfileSupport.html"></a></span><div class="tip">.NET 配置文件支持</div>
</div>
</div>
</div>
<div class="footer-wrapper">
<div class="footer clear">
<div class="copy">版权所有 © 2020 Unity Technologies. Publication 2019.4</div>
<div class="menu">
<a href="https://learn.unity.com/">教程</a><a href="https://answers.unity3d.com">社区答案</a><a href="https://support.unity3d.com/hc/en-us">知识库</a><a href="https://forum.unity3d.com">论坛</a><a href="https://unity3d.com/asset-store">Asset Store</a>
</div>
</div>
<div></div>
</div>
</div></div></div>
</div>
</body>
</html>
