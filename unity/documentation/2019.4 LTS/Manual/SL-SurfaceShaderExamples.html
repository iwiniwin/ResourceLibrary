<!DOCTYPE html><html class="no-js" lang="zh-cn">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!-- <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
      new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
      j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
      '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
      })(window,document,'script','dataLayer','GTM-5V25JL6');
    </script> -->
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="twitter:card" content="summary">
<meta property="og:title" content="表面着色器示例 - Unity 手册">
<title>表面着色器示例 - Unity 手册</title>
<meta property="og:image" content="https://docs.unity3d.com/cn/2019.4/uploads/Main/SurfaceShaderSimple.jpg">
<meta name="description" content="本页上的表面着色器示例说明了如何使用内置光照模型。如需查看如何实现自定义光照模型的示例，请参阅表面着色器光照示例。">
<meta property="og:description" content="本页上的表面着色器示例说明了如何使用内置光照模型。如需查看如何实现自定义光照模型的示例，请参阅表面着色器光照示例。">
<meta name="author" content="Unity Technologies">
<link rel="shortcut icon" href="https://unity.com/themes/contrib/unity_base/images/favicons/favicon.ico">
<link rel="icon" type="image/png" href="../StaticFiles/images/favicons/favicon.png">
<link rel="apple-touch-icon-precomposed" sizes="152x152" href="../StaticFiles/images/favicons/apple-touch-icon-152x152.png">
<link rel="apple-touch-icon-precomposed" sizes="144x144" href="../StaticFiles/images/favicons/apple-touch-icon-144x144.png">
<link rel="apple-touch-icon-precomposed" sizes="120x120" href="../StaticFiles/images/favicons/apple-touch-icon-120x120.png">
<link rel="apple-touch-icon-precomposed" sizes="114x114" href="../StaticFiles/images/favicons/apple-touch-icon-114x114.png">
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="../StaticFiles/images/favicons/apple-touch-icon-72x72.png">
<link rel="apple-touch-icon-precomposed" href="../StaticFiles/images/favicons/apple-touch-icon.png">
<meta name="msapplication-TileColor" content="#222c37">
<meta name="msapplication-TileImage" content="../StaticFiles/images/favicons/tileicon-144x144.png">
<script type="text/javascript" src="https://cdn.cookielaw.org/scripttemplates/otSDKStub.js" charset="UTF-8" data-domain-script="6e91be4c-3145-4ea2-aa64-89d716064836"></script><script type="text/javascript">
        function OptanonWrapper() { }
    </script><script>
      var docs_type = 'Manual';
      var lang = 'cn';
      var page = 'SL-SurfaceShaderExamples';
      if(!page) page = 'index';
      var version = '2019.4';
      var docs_versions = [{version: '2021.1',version_string: '2021.1',supported: true},{version: '2020.3',version_string: '2020.3',supported: true},{version: '2020.2',version_string: '2020.2',supported: false},{version: '2020.1',version_string: '2020.1',supported: false},{version: '2019.4',version_string: '2019.4',supported: true},{version: '2019.3',version_string: '2019.3',supported: false},{version: '2019.2',version_string: '2019.2',supported: false},{version: '2019.1',version_string: '2019.1',supported: false},{version: '2018.4',version_string: '2018.4',supported: true},{version: '2018.3',version_string: '2018.3',supported: false},{version: '2018.2',version_string: '2018.2',supported: false},{version: '2018.1',version_string: '2018.1',supported: false},{version: '2017.4',version_string: '2017.4',supported: false},{version: '2017.3',version_string: '2017.3',supported: false},{version: '2017.2',version_string: '2017.2',supported: false},{version: '2017.1',version_string: '2017.1',supported: false},{version: '5.6',version_string: '560',supported: false},];</script><script type="text/javascript" src="../StaticFiles/js/jquery.js"></script><script type="text/javascript" src="../StaticFiles/js/core.js"></script><script type="text/javascript" src="../StaticFiles/js/jquery.sidebar.min.js"></script><script type="text/javascript" src="docdata/toc.js"></script><script type="text/javascript" src=""></script><script type="text/javascript" src="../StaticFiles/js/custom.js"></script><link rel="stylesheet" type="text/css" href="../StaticFiles/css/core.css">
<link rel="stylesheet" type="text/css" href="../StaticFiles/css/custom.css">
<link rel="canonical" href="https://docs.unity3d.com/cn/2019.4/Manual/SL-SurfaceShaderExamples.html">
<link rel="alternate" href="https://docs.unity3d.com/en/2019.4/Manual/SL-SurfaceShaderExamples.html" hreflang="en">
<link rel="alternate" href="https://docs.unity3d.com/cn/2019.4/Manual/SL-SurfaceShaderExamples.html" hreflang="zh">
<link rel="alternate" href="https://docs.unity3d.com/ja/2019.4/Manual/SL-SurfaceShaderExamples.html" hreflang="ja">
<link rel="alternate" href="https://docs.unity3d.com/es/2019.4/Manual/SL-SurfaceShaderExamples.html" hreflang="es">
<link rel="alternate" href="https://docs.unity3d.com/kr/2019.4/Manual/SL-SurfaceShaderExamples.html" hreflang="ko">
<link rel="alternate" href="https://docs.unity3d.com/ru/2019.4/Manual/SL-SurfaceShaderExamples.html" hreflang="ru">
<link rel="alternate" href="https://docs.unity3d.com/2019.4/Documentation/Manual/SL-SurfaceShaderExamples.html" hreflang="x-default">
</head>
<body>
<noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5V25JL6" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<div class="header-wrapper">
<div id="header" class="header"><div class="content">
<div class="spacer"><div class="menu">
<div id="nav-open" for="nav-input"><span></span></div>
<div class="logo"><a href="./index.html"></a></div>
<div class="search-form"><form action="30_search.html" method="get" class="apisearch">
<input type="text" name="q" placeholder="搜索手册..." autosave="Unity Reference" results="5" class="sbox field" id="q"><input type="submit" class="submit">
</form></div>
<ul class="menu-items">
<li class="menu-item"><a href="../Manual/index.html" class="selected">手册</a></li>
<li class="menu-item"><a href="../ScriptReference/index.html" class="">脚本 API</a></li>
</ul>
</div></div>
<div class="more">
<div class="filler"></div>
<ul><li><a href="https://unity3d.com/">
                unity3d.com
              </a></li></ul>
</div>
</div></div>
<div class="toolbar"><div class="content">
<div class="version-switcher">
<div class="current toggle" data-target=".version-list"><div class="version-number">
<div class="d-inline-block">
          Version:
          <b>2019.4</b>
</div>
<div class="d-inline-block arrow"></div>
</div></div>
<div class="version-list" style="display:none;">
<ul class="versions">
<li class="supported"><a class="docs_version_url_2021.1" href="/cn/2021.1/Manual/SL-SurfaceShaderExamples.html">2021.1</a></li>
<li class="supported"><a class="docs_version_url_2020.3" href="/cn/2020.3/Manual/SL-SurfaceShaderExamples.html">2020.3</a></li>
<li class=""><a class="docs_version_url_2020.2" href="/cn/2020.2/Manual/SL-SurfaceShaderExamples.html">2020.2</a></li>
<li class=""><a class="docs_version_url_2020.1" href="/cn/2020.1/Manual/SL-SurfaceShaderExamples.html">2020.1</a></li>
<li class="supported"><a class="docs_version_url_2019.4" href="/cn/2019.4/Manual/SL-SurfaceShaderExamples.html">2019.4</a></li>
<li class=""><a class="docs_version_url_2019.3" href="/cn/2019.3/Manual/SL-SurfaceShaderExamples.html">2019.3</a></li>
<li class=""><a class="docs_version_url_2019.2" href="/cn/2019.2/Manual/SL-SurfaceShaderExamples.html">2019.2</a></li>
<li class=""><a class="docs_version_url_2019.1" href="/cn/2019.1/Manual/SL-SurfaceShaderExamples.html">2019.1</a></li>
<li class="supported"><a class="docs_version_url_2018.4" href="/cn/2018.4/Manual/SL-SurfaceShaderExamples.html">2018.4</a></li>
<li class=""><a class="docs_version_url_2018.3" href="/cn/2018.3/Manual/SL-SurfaceShaderExamples.html">2018.3</a></li>
<li class=""><a class="docs_version_url_2018.2" href="/cn/2018.2/Manual/SL-SurfaceShaderExamples.html">2018.2</a></li>
<li class=""><a class="docs_version_url_2018.1" href="/cn/2018.1/Manual/SL-SurfaceShaderExamples.html">2018.1</a></li>
<li class=""><a class="docs_version_url_2017.4" href="/cn/2017.4/Manual/SL-SurfaceShaderExamples.html">2017.4</a></li>
<li class=""><a class="docs_version_url_2017.3" href="/cn/2017.3/Manual/SL-SurfaceShaderExamples.html">2017.3</a></li>
<li class=""><a class="docs_version_url_2017.2" href="/cn/2017.2/Manual/SL-SurfaceShaderExamples.html">2017.2</a></li>
<li class=""><a class="docs_version_url_2017.1" href="/cn/2017.1/Manual/SL-SurfaceShaderExamples.html">2017.1</a></li>
<li class=""><a class="docs_version_url_560" href="/cn/560/Manual/SL-SurfaceShaderExamples.html">5.6</a></li>
<div class="versionsWithThisPage" style="display:none;"><li><p>包含此页的版本：</p></li></div>
<div class="versionsWithoutThisPage" style="display:none;"><li><p>不含此页的版本：</p></li></div>
</ul>
<ul class="description">
<li>
<div class="supported-box"></div>受支持</li>
<li>
<div class="legacy-box"></div>旧版</li>
</ul>
</div>
</div>
<ul class="nav-menu-items">
<li class="menu-item"><a href="../Manual/index.html" class="selected">手册</a></li>
<li class="menu-item"><a href="../ScriptReference/index.html" class="">脚本 API</a></li>
</ul>
<div class="lang-switcher">
<div class="current toggle" data-target=".lang-list">
<div class="lbl">语言:
        <span class="b">中文</span>
</div>
<div class="arrow"></div>
</div>
<div class="lang-list" style="display:none;"><ul>
<li><a data-lang="en" href="/2019.4/Documentation/Manual/SL-SurfaceShaderExamples.html">English</a></li>
<li><a data-lang="cn" href="/cn/2019.4/Manual/SL-SurfaceShaderExamples.html">中文</a></li>
<li><a data-lang="ja" href="/ja/2019.4/Manual/SL-SurfaceShaderExamples.html">日本語</a></li>
<li><a data-lang="es" href="/es/2019.4/Manual/SL-SurfaceShaderExamples.html">Español</a></li>
<li><a data-lang="kr" href="/kr/2019.4/Manual/SL-SurfaceShaderExamples.html">한국어</a></li>
<li><a data-lang="ru" href="/ru/2019.4/Manual/SL-SurfaceShaderExamples.html">Русский</a></li>
</ul></div>
</div>
</div></div>
</div>
<div id="master-wrapper" class="master-wrapper clear">
<div id="sidebar" class="sidebar hidden"><div class="sidebar-wrap"><div class="content"><div class="sidebar-menu"><div class="toc">
<h2>手册</h2>
<div class="version-switcher">
<div class="current toggle" data-target=".version-list"><div class="version-number">
<div class="d-inline-block">
          Version:
          <b>2019.4</b>
</div>
<div class="d-inline-block arrow"></div>
</div></div>
<div class="version-list" style="display:none;">
<ul class="versions">
<li class="supported"><a class="docs_version_url_2021.1" href="/cn/2021.1/Manual/SL-SurfaceShaderExamples.html">2021.1</a></li>
<li class="supported"><a class="docs_version_url_2020.3" href="/cn/2020.3/Manual/SL-SurfaceShaderExamples.html">2020.3</a></li>
<li class=""><a class="docs_version_url_2020.2" href="/cn/2020.2/Manual/SL-SurfaceShaderExamples.html">2020.2</a></li>
<li class=""><a class="docs_version_url_2020.1" href="/cn/2020.1/Manual/SL-SurfaceShaderExamples.html">2020.1</a></li>
<li class="supported"><a class="docs_version_url_2019.4" href="/cn/2019.4/Manual/SL-SurfaceShaderExamples.html">2019.4</a></li>
<li class=""><a class="docs_version_url_2019.3" href="/cn/2019.3/Manual/SL-SurfaceShaderExamples.html">2019.3</a></li>
<li class=""><a class="docs_version_url_2019.2" href="/cn/2019.2/Manual/SL-SurfaceShaderExamples.html">2019.2</a></li>
<li class=""><a class="docs_version_url_2019.1" href="/cn/2019.1/Manual/SL-SurfaceShaderExamples.html">2019.1</a></li>
<li class="supported"><a class="docs_version_url_2018.4" href="/cn/2018.4/Manual/SL-SurfaceShaderExamples.html">2018.4</a></li>
<li class=""><a class="docs_version_url_2018.3" href="/cn/2018.3/Manual/SL-SurfaceShaderExamples.html">2018.3</a></li>
<li class=""><a class="docs_version_url_2018.2" href="/cn/2018.2/Manual/SL-SurfaceShaderExamples.html">2018.2</a></li>
<li class=""><a class="docs_version_url_2018.1" href="/cn/2018.1/Manual/SL-SurfaceShaderExamples.html">2018.1</a></li>
<li class=""><a class="docs_version_url_2017.4" href="/cn/2017.4/Manual/SL-SurfaceShaderExamples.html">2017.4</a></li>
<li class=""><a class="docs_version_url_2017.3" href="/cn/2017.3/Manual/SL-SurfaceShaderExamples.html">2017.3</a></li>
<li class=""><a class="docs_version_url_2017.2" href="/cn/2017.2/Manual/SL-SurfaceShaderExamples.html">2017.2</a></li>
<li class=""><a class="docs_version_url_2017.1" href="/cn/2017.1/Manual/SL-SurfaceShaderExamples.html">2017.1</a></li>
<li class=""><a class="docs_version_url_560" href="/cn/560/Manual/SL-SurfaceShaderExamples.html">5.6</a></li>
<div class="versionsWithThisPage" style="display:none;"><li><p>包含此页的版本：</p></li></div>
<div class="versionsWithoutThisPage" style="display:none;"><li><p>不含此页的版本：</p></li></div>
</ul>
<ul class="description">
<li>
<div class="supported-box"></div>受支持</li>
<li>
<div class="legacy-box"></div>旧版</li>
</ul>
</div>
</div>
<div class="clear"></div>
</div></div></div></div></div>
<div id="content-wrap" class="content-wrap opened-sidebar"><div class="content-block"><div class="content">
<div class="section">
<div class="breadcrumbs clear"><ul>
<li><a href="UnityManual.html">Unity 用户手册 (2019.4 LTS)</a></li>
<li><a href="Graphics.html">图形</a></li>
<li><a href="Shaders.html">网格、材质、着色器和纹理</a></li>
<li><a href="ShadersOverview.html">编写着色器</a></li>
<li><a href="SL-Reference.html">着色器参考</a></li>
<li><a href="SL-SurfaceShaders.html">编写表面着色器</a></li>
<li>表面着色器示例</li>
</ul></div>
<div class="mb20"><div class="nextprev clear">
<div class="icon tt left mr1" data-distance="-40|-30|top">
<span class="prev"><a href="SL-RenderPipeline.html"></a></span><div class="tip">表面着色器和渲染路径</div>
</div>
<div class="icon tt right" data-distance="-40|-30|top">
<span class="next"><a href="SL-SurfaceShaderLighting.html"></a></span><div class="tip">表面着色器中的自定义光照模型</div>
</div>
</div></div>
<h1>表面着色器示例</h1>
<!--BeginSwitchLink--><!--EndSwitchLink-->
<div class="clear"></div>

<p>本页上的<a href="SL-SurfaceShaders.html">表面着色器</a>示例说明了如何使用内置光照模型。如需查看如何实现自定义光照模型的示例，请参阅<a href="SL-SurfaceShaderLightingExamples.html">表面着色器光照示例</a>。</p>

<h2>简单的着色器示例</h2>

<p>我们将从一个非常简单的着色器 (Shader) 开始，并在此基础上加以丰富。下面的着色器将表面颜色设置为“白色”。它使用内置的兰伯特（漫射）光照模型。</p>

<pre><code>  Shader "Example/Diffuse Simple" {
      SubShader {
        Tags { "RenderType" = "Opaque" }
        CGPROGRAM
        #pragma surface surf Lambert
        struct Input {
            float4 color : COLOR;
        };
        void surf (Input IN, inout SurfaceOutput o) {
            o.Albedo = 1;
        }
        ENDCG
      }
      Fallback "Diffuse"
    }
</code></pre>

<p>以下是设置了两个<a href="class-Light.html">光源</a>的模型：</p>

<figure>
<img src="../uploads/Main/SurfaceShaderSimple.jpg" alt="">
</figure>

<h2>纹理</h2>

<p>一个全白的对象很无聊，所以让我们添加一个纹理。我们将向着色器添加 <a href="SL-Properties.html">Properties</a> 代码块，这样我们将在材质中看到纹理选择器。其他更改在下文中以粗体显示。</p>

<pre><code>  Shader "Example/Diffuse Texture" {
      Properties {
        _MainTex ("Texture", 2D) = "white" {}
      }
      SubShader {
        Tags { "RenderType" = "Opaque" }
        CGPROGRAM
        #pragma surface surf Lambert
        struct Input {
            float2 uv_MainTex;
        };
        sampler2D _MainTex;
        void surf (Input IN, inout SurfaceOutput o) {
            o.Albedo = tex2D (_MainTex, IN.uv_MainTex).rgb;
        }
        ENDCG
      } 
      Fallback "Diffuse"
    }
</code></pre>

<figure>
<img src="../uploads/Main/SurfaceShaderDiffuseTex.jpg" alt="">
</figure>

<h2>法线贴图</h2>

<p>我们来添加一些法线贴图：</p>

<pre><code>  Shader "Example/Diffuse Bump" {
      Properties {
        _MainTex ("Texture", 2D) = "white" {}
        _BumpMap ("Bumpmap", 2D) = "bump" {}
      }
      SubShader {
        Tags { "RenderType" = "Opaque" }
        CGPROGRAM
        #pragma surface surf Lambert
        struct Input {
          float2 uv_MainTex;
          float2 uv_BumpMap;
        };
        sampler2D _MainTex;
        sampler2D _BumpMap;
        void surf (Input IN, inout SurfaceOutput o) {
          o.Albedo = tex2D (_MainTex, IN.uv_MainTex).rgb;
          o.Normal = UnpackNormal (tex2D (_BumpMap, IN.uv_BumpMap));
        }
        ENDCG
      } 
      Fallback "Diffuse"
    }
</code></pre>

<figure>
<img src="../uploads/Main/SurfaceShaderDiffuseBump.jpg" alt="">
</figure>

<h2>边缘光照</h2>

<p>现在，尝试添加一些边缘光照以突出游戏对象的边缘。我们将根据表面法线和视图方向之间的角度添加一些发射光照。为此，我们将使用内置的表面着色器变量 <code>viewDir</code>。</p>

<pre><code>  Shader "Example/Rim" {
      Properties {
        _MainTex ("Texture", 2D) = "white" {}
        _BumpMap ("Bumpmap", 2D) = "bump" {}
        _RimColor ("Rim Color", Color) = (0.26,0.19,0.16,0.0)
        _RimPower ("Rim Power", Range(0.5,8.0)) = 3.0
      }
      SubShader {
        Tags { "RenderType" = "Opaque" }
        CGPROGRAM
        #pragma surface surf Lambert
        struct Input {
            float2 uv_MainTex;
            float2 uv_BumpMap;
            float3 viewDir;
        };
        sampler2D _MainTex;
        sampler2D _BumpMap;
        float4 _RimColor;
        float _RimPower;
        void surf (Input IN, inout SurfaceOutput o) {
            o.Albedo = tex2D (_MainTex, IN.uv_MainTex).rgb;
            o.Normal = UnpackNormal (tex2D (_BumpMap, IN.uv_BumpMap));
            half rim = 1.0 - saturate(dot (normalize(IN.viewDir), o.Normal));
            o.Emission = _RimColor.rgb * pow (rim, _RimPower);
        }
        ENDCG
      } 
      Fallback "Diffuse"
    }
</code></pre>

<figure>
<img src="../uploads/Main/SurfaceShaderRim.jpg" alt="">
</figure>

<h2>细节纹理</h2>

<p>为获得不同效果，让我们添加一个与基础纹理结合的细节纹理。细节纹理通常在材质中使用相同的 UV，但使用不同平铺，因此我们需要使用不同的输入 UV 坐标。</p>

<pre><code>  Shader "Example/Detail" {
      Properties {
        _MainTex ("Texture", 2D) = "white" {}
        _BumpMap ("Bumpmap", 2D) = "bump" {}
        _Detail ("Detail", 2D) = "gray" {}
      }
      SubShader {
        Tags { "RenderType" = "Opaque" }
        CGPROGRAM
        #pragma surface surf Lambert
        struct Input {
            float2 uv_MainTex;
            float2 uv_BumpMap;
            float2 uv_Detail;
        };
        sampler2D _MainTex;
        sampler2D _BumpMap;
        sampler2D _Detail;
        void surf (Input IN, inout SurfaceOutput o) {
            o.Albedo = tex2D (_MainTex, IN.uv_MainTex).rgb;
            o.Albedo *= tex2D (_Detail, IN.uv_Detail).rgb * 2;
            o.Normal = UnpackNormal (tex2D (_BumpMap, IN.uv_BumpMap));
        }
        ENDCG
      } 
      Fallback "Diffuse"
    }
</code></pre>

<p>使用纹理棋盘格不一定有实际意义，但在此示例中可用于说明其作用：</p>

<figure>
<img src="../uploads/Main/SurfaceShaderDetailTex.jpg" alt="">
</figure>

<h2>屏幕空间中的细节纹理</h2>

<p>屏幕空间中的细节纹理对于士兵头部模型没有实际意义，但是在这里可用于说明如何使用内置的 <code>screenPos</code> 输入：</p>

<pre><code>  Shader "Example/ScreenPos" {
      Properties {
        _MainTex ("Texture", 2D) = "white" {}
        _Detail ("Detail", 2D) = "gray" {}
      }
      SubShader {
        Tags { "RenderType" = "Opaque" }
        CGPROGRAM
        #pragma surface surf Lambert
        struct Input {
            float2 uv_MainTex;
            float4 screenPos;
        };
        sampler2D _MainTex;
        sampler2D _Detail;
        void surf (Input IN, inout SurfaceOutput o) {
            o.Albedo = tex2D (_MainTex, IN.uv_MainTex).rgb;
            float2 screenUV = IN.screenPos.xy / IN.screenPos.w;
            screenUV *= float2(8,6);
            o.Albedo *= tex2D (_Detail, screenUV).rgb * 2;
        }
        ENDCG
      } 
      Fallback "Diffuse"
    }
</code></pre>

<p>从上面的着色器删除了法线贴图，只是为了缩短代码长度：</p>

<figure>
<img src="../uploads/Main/SurfaceShaderDetailTexScreenPos.jpg" alt="">
</figure>

<h2>立方体贴图反射</h2>

<p>下面的着色器将使用内置 <code>worldRefl</code> 输入来进行立方体贴图反射。它与内置的反射/漫射着色器非常类似：</p>

<pre><code>  Shader "Example/WorldRefl" {
      Properties {
        _MainTex ("Texture", 2D) = "white" {}
        _Cube ("Cubemap", CUBE) = "" {}
      }
      SubShader {
        Tags { "RenderType" = "Opaque" }
        CGPROGRAM
        #pragma surface surf Lambert
        struct Input {
            float2 uv_MainTex;
            float3 worldRefl;
        };
        sampler2D _MainTex;
        samplerCUBE _Cube;
        void surf (Input IN, inout SurfaceOutput o) {
            o.Albedo = tex2D (_MainTex, IN.uv_MainTex).rgb * 0.5;
            o.Emission = texCUBE (_Cube, IN.worldRefl).rgb;
        }
        ENDCG
      } 
      Fallback "Diffuse"
    }
</code></pre>

<p>因为它将反射颜色指定为 __Emission__，所以我们得到了一个非常闪亮的士兵：</p>

<figure>
<img src="../uploads/Main/SurfaceShaderWorldRefl.jpg" alt="">
</figure>

<p>如果您想做一些受法线贴图影响的反射，需要稍微复杂一些：需要将 <code>INTERNAL_DATA</code> 添加到 <code>Input</code> 结构，并使用 <code>WorldReflectionVector</code> 函数在写入法线输出后计算每像素反射矢量。</p>

<pre><code>  Shader "Example/WorldRefl Normalmap" {
      Properties {
        _MainTex ("Texture", 2D) = "white" {}
        _BumpMap ("Bumpmap", 2D) = "bump" {}
        _Cube ("Cubemap", CUBE) = "" {}
      }
      SubShader {
        Tags { "RenderType" = "Opaque" }
        CGPROGRAM
        #pragma surface surf Lambert
        struct Input {
            float2 uv_MainTex;
            float2 uv_BumpMap;
            float3 worldRefl;
            INTERNAL_DATA
        };
        sampler2D _MainTex;
        sampler2D _BumpMap;
        samplerCUBE _Cube;
        void surf (Input IN, inout SurfaceOutput o) {
            o.Albedo = tex2D (_MainTex, IN.uv_MainTex).rgb * 0.5;
            o.Normal = UnpackNormal (tex2D (_BumpMap, IN.uv_BumpMap));
            o.Emission = texCUBE (_Cube, WorldReflectionVector (IN, o.Normal)).rgb;
        }
        ENDCG
      } 
      Fallback "Diffuse"
    }
</code></pre>

<p>下面是一个进行了法线贴图的闪亮士兵：</p>

<figure>
<img src="../uploads/Main/SurfaceShaderWorldReflNormalmap.jpg" alt="">
</figure>

<h2>通过世界空间位置进行的切片</h2>

<p>下面的着色器通过丢弃几乎水平的环形中的像素来对游戏对象“切片”。为实现此效果，它使用了基于像素世界位置的 Cg/HLSL 函数 <code>clip()</code>。我们将使用内置的表面着色器变量 <code>worldPos</code>。</p>

<pre><code>  Shader "Example/Slices" {
      Properties {
        _MainTex ("Texture", 2D) = "white" {}
        _BumpMap ("Bumpmap", 2D) = "bump" {}
      }
      SubShader {
        Tags { "RenderType" = "Opaque" }
        Cull Off
        CGPROGRAM
        #pragma surface surf Lambert
        struct Input {
            float2 uv_MainTex;
            float2 uv_BumpMap;
            float3 worldPos;
        };
        sampler2D _MainTex;
        sampler2D _BumpMap;
        void surf (Input IN, inout SurfaceOutput o) {
            clip (frac((IN.worldPos.y+IN.worldPos.z*0.1) * 5) - 0.5);
            o.Albedo = tex2D (_MainTex, IN.uv_MainTex).rgb;
            o.Normal = UnpackNormal (tex2D (_BumpMap, IN.uv_BumpMap));
        }
        ENDCG
      } 
      Fallback "Diffuse"
    }
</code></pre>

<figure>
<img src="../uploads/Main/SurfaceShaderSlices.jpg" alt="">
</figure>

<h2>使用顶点修改器进行法线挤出</h2>

<p>可以使用“顶点修改器”函数来修改顶点着色器中的传入顶点数据。这可用于程序化动画和沿法线挤出等操作。表面着色器编译指令 <code>vertex:functionName</code> 将用于此目的，其中的一个函数采用 <code>inout appdata_full</code> 参数。</p>

<p>以下着色器沿着法线按照材质中指定的量移动顶点：</p>

<pre><code>  Shader "Example/Normal Extrusion" {
      Properties {
        _MainTex ("Texture", 2D) = "white" {}
        _Amount ("Extrusion Amount", Range(-1,1)) = 0.5
      }
      SubShader {
        Tags { "RenderType" = "Opaque" }
        CGPROGRAM
        #pragma surface surf Lambert vertex:vert
        struct Input {
            float2 uv_MainTex;
        };
        float _Amount;
        void vert (inout appdata_full v) {
            v.vertex.xyz += v.normal * _Amount;
        }
        sampler2D _MainTex;
        void surf (Input IN, inout SurfaceOutput o) {
            o.Albedo = tex2D (_MainTex, IN.uv_MainTex).rgb;
        }
        ENDCG
      } 
      Fallback "Diffuse"
    }
</code></pre>

<p>沿着法线移动顶点会产生一个肥胖的士兵：</p>

<figure>
<img src="../uploads/Main/SurfaceShaderNormalExtrusion.jpg" alt="">
</figure>

<h2>每顶点计算的自定义数据</h2>

<p>使用顶点修改器函数，还可以在顶点着色器中计算自定义数据，然后将数据按像素传递给表面着色器函数。此情况下使用相同的编译指令 <code>vertex:functionName</code>，但该函数应采用两个参数：<code>inout appdata_full</code> 和 <code>out Input</code>。您可以在其中填写除内置值以外的任何输入成员。</p>

<p><strong>注意：</strong>以这种方式使用的自定义输入成员不得包含以“uv”开头的名称，否则它们将无法正常工作。</p>

<p>下面的示例定义了一个在顶点函数中计算的自定义 <code>float3 customColor</code> 成员：</p>

<pre><code>  Shader "Example/Custom Vertex Data" {
      Properties {
        _MainTex ("Texture", 2D) = "white" {}
      }
      SubShader {
        Tags { "RenderType" = "Opaque" }
        CGPROGRAM
        #pragma surface surf Lambert vertex:vert
        struct Input {
            float2 uv_MainTex;
            float3 customColor;
        };
        void vert (inout appdata_full v, out Input o) {
            UNITY_INITIALIZE_OUTPUT(Input,o);
            o.customColor = abs(v.normal);
        }
        sampler2D _MainTex;
        void surf (Input IN, inout SurfaceOutput o) {
            o.Albedo = tex2D (_MainTex, IN.uv_MainTex).rgb;
            o.Albedo *= IN.customColor;
        }
        ENDCG
      } 
      Fallback "Diffuse"
    }
</code></pre>

<p>在此示例中，<code>customColor</code> 设置为法线的绝对值：</p>

<figure>
<img src="../uploads/Main/SurfaceShaderCustomVertexData.jpg" alt="">
</figure>

<p>更实际的用途可能是计算内置输入变量不提供的任何每顶点数据；或优化着色器计算。例如，可以在游戏对象的顶点处计算边缘光照，而不是在表面着色器中按照每个像素进行计算。</p>

<h2>最终颜色修改器</h2>

<p>可以使用“最终颜色修改器”函数来修改着色器计算的最终颜色。表面着色器编译指令 <code>finalcolor:functionName</code> 将用于此目的，其中的一个函数采用 <code>Input IN, SurfaceOutput o, inout fixed4 color</code> 参数。</p>

<p>下面是一个简单的着色器，它将色调应用于最终颜色。这与仅对表面反照率颜色应用色调不同：此色调还会影响来自光照贴图、光照探针和类似额外来源的任何颜色。</p>

<pre><code>  Shader "Example/Tint Final Color" {
      Properties {
        _MainTex ("Texture", 2D) = "white" {}
        _ColorTint ("Tint", Color) = (1.0, 0.6, 0.6, 1.0)
      }
      SubShader {
        Tags { "RenderType" = "Opaque" }
        CGPROGRAM
        #pragma surface surf Lambert finalcolor:mycolor
        struct Input {
            float2 uv_MainTex;
        };
        fixed4 _ColorTint;
        void mycolor (Input IN, SurfaceOutput o, inout fixed4 color)
        {
            color *= _ColorTint;
        }
        sampler2D _MainTex;
        void surf (Input IN, inout SurfaceOutput o) {
             o.Albedo = tex2D (_MainTex, IN.uv_MainTex).rgb;
        }
        ENDCG
      } 
      Fallback "Diffuse"
    }
</code></pre>

<figure>
<img src="../uploads/Main/SurfaceShaderFinalColorSimple.jpg" alt="">
</figure>

<h2>使用最终颜色修改器自定义雾效</h2>

<p>使用最终颜色修改器（见上文）的常见情况是在前向渲染中实现完全自定义的雾效。雾效需要影响最终计算的像素着色器颜色，这正是 <code>finalcolor</code> 修改器的功能。</p>

<p>下面是一个根据与屏幕中心的距离应用雾效色调的着色器。此着色器将顶点修改器与自定义顶点数据 (<code>fog</code>) 和最终颜色修改器组合在一起。用于前向渲染附加通道时，雾效需要淡化为黑色。此示例将解决这一问题并检查是否有 <code>UNITY_PASS_FORWARDADD</code>。</p>

<pre><code>  Shader "Example/Fog via Final Color" {
      Properties {
        _MainTex ("Texture", 2D) = "white" {}
        _FogColor ("Fog Color", Color) = (0.3, 0.4, 0.7, 1.0)
      }
      SubShader {
        Tags { "RenderType" = "Opaque" }
        CGPROGRAM
        #pragma surface surf Lambert finalcolor:mycolor vertex:myvert
        struct Input {
            float2 uv_MainTex;
            half fog;
        };
        void myvert (inout appdata_full v, out Input data)
        {
            UNITY_INITIALIZE_OUTPUT(Input,data);
            float4 hpos = UnityObjectToClipPos(v.vertex);
          hpos.xy/=hpos.w;
            data.fog = min (1, dot (hpos.xy, hpos.xy)*0.5);
        }
        fixed4 _FogColor;
        void mycolor (Input IN, SurfaceOutput o, inout fixed4 color)
        {
            fixed3 fogColor = _FogColor.rgb;
            #ifdef UNITY_PASS_FORWARDADD
            fogColor = 0;
            #endif
            color.rgb = lerp (color.rgb, fogColor, IN.fog);
        }
        sampler2D _MainTex;
        void surf (Input IN, inout SurfaceOutput o) {
             o.Albedo = tex2D (_MainTex, IN.uv_MainTex).rgb;
        }
        ENDCG
      } 
      Fallback "Diffuse"
    }
</code></pre>

<figure>
<img src="../uploads/Main/SurfaceShaderFinalColorFog.jpg" alt="">
</figure>

<h2>线性雾效</h2>

<pre><code>Shader "Example/Linear Fog" {
  Properties {
    _MainTex ("Base (RGB)", 2D) = "white" {}
  }
  SubShader {
    Tags { "RenderType"="Opaque" }
    LOD 200
    
    CGPROGRAM
    #pragma surface surf Lambert finalcolor:mycolor vertex:myvert
    #pragma multi_compile_fog

    sampler2D _MainTex;
    uniform half4 unity_FogStart;
    uniform half4 unity_FogEnd;

    struct Input {
      float2 uv_MainTex;
      half fog;
    };

    void myvert (inout appdata_full v, out Input data) {
      UNITY_INITIALIZE_OUTPUT(Input,data);
      float pos = length(UnityObjectToViewPos(v.vertex).xyz);
      float diff = unity_FogEnd.x - unity_FogStart.x;
      float invDiff = 1.0f / diff;
      data.fog = clamp ((unity_FogEnd.x - pos) * invDiff, 0.0, 1.0);
    }
    void mycolor (Input IN, SurfaceOutput o, inout fixed4 color) {
      #ifdef UNITY_PASS_FORWARDADD
        UNITY_APPLY_FOG_COLOR(IN.fog, color, float4(0,0,0,0));
      #else
        UNITY_APPLY_FOG_COLOR(IN.fog, color, unity_FogColor);
      #endif
    }

    void surf (Input IN, inout SurfaceOutput o) {
      half4 c = tex2D (_MainTex, IN.uv_MainTex);
      o.Albedo = c.rgb;
      o.Alpha = c.a;
    }
    ENDCG
  } 
  FallBack "Diffuse"
}
</code></pre>

<h2>贴花</h2>

<p>贴花通常用于在运行时向材质添加细节（例如，子弹冲击力效果）。贴花在延迟渲染中特别有用，因为贴花在照亮之前会改变 G 缓冲区，因此可以节省开销。</p>

<p>在常规情况下，贴花应该在不透明对象之后渲染，并且不应该是阴影投射物，如以下示例中的 ShaderLab“Tags”中所示。</p>

<pre><code>Shader "Example/Decal" {
  Properties {
    _MainTex ("Base (RGB)", 2D) = "white" {}
  }
  SubShader {
    Tags { "RenderType"="Opaque" "Queue"="Geometry+1" "ForceNoShadowCasting"="True" }
    LOD 200
    Offset -1, -1
    
    CGPROGRAM
    #pragma surface surf Lambert decal:blend
    
    sampler2D _MainTex;
    
    struct Input {
      float2 uv_MainTex;
    };
    
    void surf (Input IN, inout SurfaceOutput o) {
        half4 c = tex2D (_MainTex, IN.uv_MainTex);
        o.Albedo = c.rgb;
        o.Alpha = c.a;
      }
    ENDCG
    }
}
</code></pre>
<!-- area:graphics -->
<div class="nextprev clear">
<div class="icon tt left mr1" data-distance="-40|-30|top">
<span class="prev"><a href="SL-RenderPipeline.html"></a></span><div class="tip">表面着色器和渲染路径</div>
</div>
<div class="icon tt right" data-distance="-40|-30|top">
<span class="next"><a href="SL-SurfaceShaderLighting.html"></a></span><div class="tip">表面着色器中的自定义光照模型</div>
</div>
</div>
</div>
<div class="footer-wrapper">
<div class="footer clear">
<div class="copy">版权所有 © 2020 Unity Technologies. Publication 2019.4</div>
<div class="menu">
<a href="https://learn.unity.com/">教程</a><a href="https://answers.unity3d.com">社区答案</a><a href="https://support.unity3d.com/hc/en-us">知识库</a><a href="https://forum.unity3d.com">论坛</a><a href="https://unity3d.com/asset-store">Asset Store</a>
</div>
</div>
<div></div>
</div>
</div></div></div>
</div>
</body>
</html>
